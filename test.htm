<!DOCTYPE html>

<head>
    <link rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.5.0/build/styles/default.min.css">
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.5.0/build/highlight.min.js"></script>
    <script src="spin.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
    <p>
        Bla bla
    </p>
    <pre><code>
        #include "stdio.h"
        void anus(int aaa) {
            int onek = 1;
            printf("onek $d",aaa + 1);
        }
    </code></pre>
    <pre><code>
        cd ../onek
        pause
        dir
    </code></pre>
    <pre><code>
PUB main (abc,d) : onek | byte test
  onek := negx
    </code></pre>
    <pre><code>
#define TEST 1
#include "test.spin"
{{
    *****************************************
    * Frequency Synthesizer demo v1.1       *
    * Author: Beau Schwabe                  *
    * Copyright (c) 2007 Parallax           *
    * See end of file for terms of use.     *
    *****************************************
        Original Author: Chip Gracey
        Modified by Beau Schwabe
    *****************************************
    }}
    {
    Revision History:
                        Version 1.0   -    original file created
                        
                        Version 1.1   -    For Channel &quot;B&quot; there was a typo in the &apos;Synth&apos; object
                                            The line that reads...
                                            DIRB[Pin]~~                        &apos;make pin output
                                            ...should read...  
                                            DIRA[Pin]~~                        &apos;make pin output
    }
    PUB Synth(CTR_AB, Pin, Freq) | s, d, ctr, frq '' test
    
        Freq := Freq #&gt; 0 &lt;# 128_000_000     &apos;limit frequency range
        
        if Freq &lt; 500_000                    &apos;if 0 to 499_999 Hz,
        ctr := constant(%00100 &lt;&lt; 26)      &apos;..set NCO mode
        s := 1                             &apos;..shift = 1
        else                                 &apos;if 500_000 to 128_000_000 Hz,
        ctr := constant(%00010 &lt;&lt; 26)      &apos;..set PLL mode
        d := &gt;|((Freq - 1) / 1_000_000)    &apos;determine PLLDIV
        s := 4 - d                         &apos;determine shift
        ctr |= d &lt;&lt; 23                     &apos;set PLLDIV
        
        frq := fraction(Freq, CLKFREQ, s)    &apos;Compute FRQA/FRQB value
        ctr |= Pin                           &apos;set PINA to complete CTRA/CTRB value
    
        if CTR_AB == &quot;A&quot;
            CTRA := ctr                        &apos;set CTRA
            FRQA := frq                        &apos;set FRQA                   
            DIRA[Pin]~~                        &apos;make pin output
            
        if CTR_AB == &quot;B&quot;
            CTRB := ctr                        &apos;set CTRB
            FRQB := frq                        &apos;set FRQB                   
            DIRA[Pin]~~                        &apos;make pin output
    
    PRI   fraction (a, b, shift) : f
    
        if shift &gt; 0                         &apos;if shift, pre-shift a or b left
        a &lt;&lt;= shift                        &apos;to maintain significant bits while 
        if shift &lt; 0                         &apos;insuring proper result
        b &lt;&lt;= -shift
        
        repeat 32                            &apos;perform long division of a/b
        f &lt;&lt;= 1
        if a =&gt; b
            a -= b
            f++           
        a &lt;&lt;= 1
    DAT
    {{
    &boxdr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdl;
    &boxv;                                                   TERMS OF USE: MIT License                                                  &boxv;
    &boxvr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxvl;
    &boxv;Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation    &boxv;
    &boxv;files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy,    &boxv;
    &boxv;modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software&boxv;
    &boxv;is furnished to do so, subject to the following conditions:                                                                   &boxv;
    &boxv;                                                                                                                              &boxv;
    &boxv;The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.&boxv;
    &boxv;                                                                                                                              &boxv;
    &boxv;THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE          &boxv;
    &boxv;WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR         &boxv;
    &boxv;COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,   &boxv;
    &boxv;ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                         &boxv;
    &boxur;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxul;
    }}    
    </code></pre>
    
    <pre><code>
_CLKMODE = XTAL1 + PLL2X
{{
&boxdr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhd;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhd;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhd;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdl;
&boxv; Stereo Spatializer v1.0                   &boxv; by Chip Gracey &boxv; Copyright (c) 2006 Parallax, Inc. &boxv; 26 October 2006 &boxv;
&boxvr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhu;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhu;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhu;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxvl;
&boxv;                                                                                                                  &boxv;
&boxv; This object spatializes up to four monaural audio sample streams into a time-conscious stereo sound field with   &boxv;
&boxv; angle and depth controls for each channel. It requires one cog and at least 80 MHz.                              &boxv; 
&boxv;                                                                                                                  &boxv; 
&boxv; The stereo spatializer is controlled via 13 single-word parameters which must reside in the parent object:       &boxv;                                                                                      
&boxv;                                                                                                                  &boxv; 
&boxv; VAR word input[4]    &apos;pointers to longs which receive sample streams for each channel (0 = disable)              &boxv; 
&boxv; VAR word angle[4]    &apos;angles for each channel (0..32768..65535 = left..center..right)                            &boxv; 
&boxv; VAR word depth[4]    &apos;depths for each channel (0..65535 = near..far)                                             &boxv; 
&boxv; VAR word knobs       &apos;bit fields for controlling depth decay, echoes, and dither                                 &boxv; 
&boxv;                                                                                                                  &boxv; 
&boxv; The &apos;input&apos; words are used to point the spatializer to longs which are receiving 32-bit monaural sample streams  &boxv; 
&boxv; in real-time (preferably at a matching 20KHz sample rate). Any time an input is set to 0, that channel will be   &boxv;    
&boxv; disabled.                                                                                                        &boxv; 
&boxv;                                                                                                                  &boxv; 
&boxv; The &apos;angle&apos; words determine where, from left to right, the corresponding inputs will be placed within the sound  &boxv; 
&boxv; field. This is achieved by using the sine of the angle (as &pm;90 degrees) to compute a complimentary 0..3dB decay  &boxv; 
&boxv; and &pm;350&micro;s-maximum delay for each ear. For example, when the angle is all the way left, the left channel         &boxv; 
&boxv; receives a -0dB signal with a -350&micro;s delay, while the right channel receives a -3dB signal with a +350&micro;s delay.  &boxv; 
&boxv; When the angle is exactly center, both channels receive a -1.5dB signal with a 0&micro;s delay. The spatializer        &boxv; 
&boxv; maintains its own internal angles which &apos;chase&apos; the angle words at a rate of 1.76 degrees per millisecond to     &boxv; 
&boxv; avoid audible discontinuities in the sample delay buffer.                                                        &boxv;                 
&boxv;                                                                                                                  &boxv; 
&boxv; The &apos;depth&apos; words determine how far away the corresponding inputs will be placed into the sound field. This is   &boxv; 
&boxv; achieved by logarithmically decaying the input samples by the depth and then summing them into the delay buffer  &boxv; 
&boxv; using depth / 16 (limited to buffer size - 16) as a whole-sample offset.  This creates a time delay before a     &boxv; 
&boxv; sample will be heard, but more importantly allows for doppler shifts to occur when the depths are changed. Note  &boxv; 
&boxv; that the spatializer&apos;s 20KHz input/output sample rate has a period of 50&micro;s, which is far too coarse for a        &boxv; 
&boxv; natural-sounding delay step. The unit of depth delay is 1/16 of a sample period, or 3.125&micro;s. This provides good  &boxv; 
&boxv; depth resolution which fills a word, but is still inadequate for a natural-sounding delay step. Internally,      &boxv; 
&boxv; delay is tracked in base units of 1/256 of a sample period, or 195ns &boxh;&boxh; a time in which sounds travels only      &boxv; 
&boxv; 67&micro;m! To realize this resolution, input samples are apportioned into two parts and then summed into adjacent     &boxv; 
&boxv; samples in the delay buffer. The spatializer maintains its internal high-resolution depths by &apos;chasing&apos; the      &boxv; 
&boxv; depth words using a difference-driven, dampened acceleration algorithm. This insures that pitch changes          &boxv; 
&boxv; resulting from doppler shifts occur very smoothly and continuously in response to the depth words being modified &boxv; 
&boxv; over time.                                                                                                       &boxv; 
&boxv;                                                                                                                  &boxv; 
&boxv; The &apos;knobs&apos; word contains four 3-bit fields which are arranged as follows: %NNN_XXX_PPP_DDD                      &boxv; 
&boxv;                                                                                                                  &boxv; 
&boxv;            &boxdr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhd;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhd;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhd;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhd;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdl;                          &boxv; 
&boxv;            &boxv; knobs &boxv;  %NNN  &boxv;    %XXX    &boxv;     %PPP      &boxv;            %DDD            &boxv;                          &boxv; 
&boxv;            &boxvr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxvh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxvh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxvh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxvh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxvl;                          &boxv; 
&boxv;            &boxv; value &boxv; dither &boxv; cross echo &boxv; parallel echo &boxv;      depth decay rate      &boxv;                          &boxv; 
&boxv;            &boxvr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxvh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxvh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxvh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxvh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxvl;                          &boxv; 
&boxv;            &boxv;  000  &boxv; -24dB  &boxv;   -24dB    &boxv;     -24dB     &boxv; -3dB per 32768 depth units &boxv;                          &boxv; 
&boxv;            &boxv;  001  &boxv; -27dB  &boxv;   -21dB    &boxv;     -21dB     &boxv; -3dB per 16384 depth units &boxv;                          &boxv; 
&boxv;            &boxv;  010  &boxv; -30dB  &boxv;   -18dB    &boxv;     -18dB     &boxv; -3dB per 8192 depth units  &boxv;                          &boxv; 
&boxv;            &boxv;  011  &boxv; -33dB  &boxv;   -15dB    &boxv;     -15dB     &boxv; -3dB per 4096 depth units  &boxv;                          &boxv; 
&boxv;            &boxv;  100  &boxv; -36dB  &boxv;   -12dB    &boxv;     -12dB     &boxv; -3dB per 2048 depth units  &boxv;                          &boxv; 
&boxv;            &boxv;  101  &boxv; -39dB  &boxv;   -9dB     &boxv;     -9dB      &boxv; -3dB per 1024 depth units  &boxv;                          &boxv; 
&boxv;            &boxv;  110  &boxv; -42dB  &boxv;   -6dB     &boxv;     -6dB      &boxv; -3dB per 512 depth units   &boxv;                          &boxv; 
&boxv;            &boxv;  111  &boxv; -45dB  &boxv;   -3dB     &boxv;     -3dB      &boxv; -3dB per 256 depth units   &boxv;                          &boxv; 
&boxv;            &boxur;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhu;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhu;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhu;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhu;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxul;                          &boxv; 
&boxv;                                                                                                                  &boxv; 
&boxv; When starting the spatializer, you must give it a buffer of longs to be used as a stereo sample delay. The size  &boxv; 
&boxv; of this buffer must range from 16 to 4096 longs. With the minimal 16 longs, you&apos;ll have only enough buffer for   &boxv; 
&boxv; the ear-to-ear delays needed for directional cuing. Your depth delay will be stuck at 0. To be able to generate  &boxv; 
&boxv; depth delays, doppler shifts, and significant echoes, you will need to increase the buffer size. For every extra &boxv; 
&boxv; 18 longs, you&apos;ll get ~1 foot (0.9ms) of depth delay. For every extra 58 longs, you&apos;ll get ~1 meter (2.9ms) of    &boxv; 
&boxv; depth delay. The maximum extra 4080 longs (4096 total) will yield a depth delay of ~230 feet or ~70 meters,      &boxv; 
&boxv; which is 204ms. Regardless of your buffer size, you can always specify depths up to 65535 to achieve depth       &boxv; 
&boxv; decay.  However, for depth delay purposes, the maximum usable depth value will be (buffer size - 16) * 16.       &boxv;                            
&boxv;                                                                                                                  &boxv; 
&boxv; The spatializer generates stereo audio samples at a continuous rate of 20KHz. Samples may be output to pins via  &boxv; 
&boxv; delta-modulation for either RC filtering or direct transducer driving. In this case, 4x-oversampled dither is    &boxv; 
&boxv; used to eliminate both quantization noise from delta-modulation and pico-second jitter noise from on-chip        &boxv; 
&boxv; crosstalk between nearby pins. Normally, these two noise sources generate distracting buzzes, whines, and hash,  &boxv; 
&boxv; but dithering removes them in exchange for lower-level white noise which does not draw your attention. The       &boxv; 
&boxv; dither level can be adjusted through the &apos;knobs&apos; word. You can turn it way down way to hear what almost no       &boxv; 
&boxv; dither sounds like. Aside from outputting to pins, sample pairs are always streamed into a special long so that  &boxv; 
&boxv; other objects can access them in real-time.                                                                      &boxv;                                  
&boxv;                                                                                                                  &boxv; 
&boxur;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxul;                                       
                                                                                                                                                
}}                                                                                                                                            
VAR                                                                                                                                           
                                                                                                                                                
    long  cog                                                                                                                                   
                                                                                                                                                
    long  args[3], samples                                &apos;4 longs    ...must be                                                                
    long  dira_, dirb_, ctra_, ctrb_, cnt_                &apos;5 longs    ...contiguous                                                             

CON
    TESTCON = 1
    _XINFREQ = 2
                                                                                                                                                
PUB start(settings_ptr, buffer_ptr, buffer_size, lpos_pin, lneg_pin, rpos_pin, rneg_pin) : okay | i                                           
                                                                                                                                                
&apos;&apos; Start stereo spatializer driver - starts a cog                                                                                             
&apos;&apos; returns false if no cog available                                                                                                          
&apos;&apos;                                                                                                                                            
&apos;&apos;   settings_ptr = pointer to settings (13 words)                                                                                            
&apos;&apos;     buffer_ptr = pointer to buffer (16 to 4096 longs)                                                                                      
&apos;&apos;    buffer_size = number of longs in buffer                                                                                                 
&apos;&apos;       lpos_pin = left positive delta-modulation pin (-1 to disable)                                                                        
&apos;&apos;       lneg_pin = left negative delta-modulation pin (lpos_pin must also be enabled, -1 to disable)                                         
&apos;&apos;       rpos_pin = right positive delta-modulation pin (-1 to disable)                                                                       
&apos;&apos;       rneg_pin = right negative delta-modulation pin (rpos_pin must also be enabled, -1 to disable)                                        
                                                                                                                                                
    &apos;Reset driver                                                                                                                               
    stop                                                                                                                                        
                                                                                                                                                
    &apos;Remember arguments                                                                                                                         
    longmove(@args, @settings_ptr, 3)                                                                                                           
                                                                                                                                                
    &apos;If delta-modulation pin(s) enabled, ready output(s) and ready ctra/ctrb for duty mode                                                      
    repeat i from 0 to 2 step 2                                                                                                                 
    if lpos_pin[i] &gt; -1                                                                                                                       
        dira_[lpos_pin[i] &gt;&gt; 5 &amp; 1] |= |&lt; lpos_pin[i]                                                                                           
        ctra_[i &gt;&gt; 1] := $18000000 + lpos_pin[i] &amp; $3F                                                                                          
        if lneg_pin[i] &gt; -1                                                                                                                     
        dira_[lneg_pin[i] &gt;&gt; 5 &amp; 1] |= |&lt; lneg_pin[i]                                                                                         
        ctra_[i &gt;&gt; 1] += $04000000 + (lneg_pin[i] &amp; $3F) &lt;&lt; 9                                                                                 
                                                                                                                                                
    &apos;Ready 20KHz sample period                                                                                                                  
    cnt_ := clkfreq / 20_000                                                                                                                    
                                                                                                                                                
    &apos;Launch spatializer cog                                                                                                                     
    return cog := cognew(@entry, @samples) + 1                                                                                                  
                                                                                                                                                
                                                                                                                                                
PUB stop                                                                                                                                      
                                                                                                                                                
&apos;&apos; Stop stereo spatializer driver - frees a cog                                                                                               
                                                                                                                                                
    &apos;If already running, stop spatializer cog                                                                                                   
    if cog                                                                                                                                      
    cogstop(cog~ -  1)                                                                                                                        
                                                                                                                                                
    &apos;Reset variables                                                                                                                            
    longfill(@dira_, 0, 4)                                                                                                                      
                                                                                                                                                
                                                                                                                                                
PUB sample_ptr : ptr                                                                                                                          
                                                                                                                                                
&apos;&apos; Returns the address of the long which receives the stereo audio samples in real-time                                                       
&apos;&apos; (two signed 16-bit values updated at 20KHz - left in top word, right in bottom word)                                                       
                                                                                                                                                
    return @samples                                                                                                                             
                                                                                                                                                
                                                                                                                                                
DAT                                                                                                                                           
                                                                                                                                                
&apos; &boxdr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdl;                                                                                                                        
&apos; &boxv;  Initialization  &boxv;                                                                                                                        
&apos; &boxur;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxul;                                                                                                                        
                                                                                                                                                
entry                   org                                                                                                                   
                                                                                                                                                
:zero                   mov     reserves,#0             &apos;zero all reserved data                                                               
                        add     :zero,h00000200                                                                                               
                        djnz    clear_cnt,#:zero     

                        mov     t1,par                  &apos;get settings pointers
                        sub     t1,#3*4
                        rdlong  input_ptr,t1
                        mov     angle_ptr,input_ptr
                        add     angle_ptr,#4*2
                        mov     depth_ptr,angle_ptr
                        add     depth_ptr,#4*2
                        mov     knobs_ptr,depth_ptr
                        add     knobs_ptr,#4*2

                        add     t1,#1*4                 &apos;get buffer base
                        rdlong  buff_base,t1
                        
                        add     t1,#1*4                 &apos;get buffer size
                        rdlong  buff_size,t1
                        shl     buff_size,#2

                        mov     buff_limit,buff_size    &apos;compute buffer limit
                        sub     buff_limit,#4
                        
                        mov     buff_clamp,buff_size    &apos;compute buffer clamp
                        sub     buff_clamp,#16*4
                        shl     buff_clamp,#8-2

                        add     t1,#2*4                 &apos;get dira/dirb/ctra/ctrb
                        mov     t2,#4
:regs                   rdlong  dira,t1
                        add     t1,#1*4
                        add     :regs,h00000200
                        djnz    t2,#:regs

                        rdlong  cnt_ticks,t1            &apos;get cnt ticks

                        mov     cnt_value,cnt           &apos;prepare for initial waitcnt
                        add     cnt_value,cnt_ticks


&apos; &boxdr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdl;
&apos; &boxv;  Spatializer Loop  &boxv;
&apos; &boxur;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxul;

&apos; Wait for next sample period, then get knob settings

loop                    waitcnt cnt_value,cnt_ticks     &apos;wait for sample period

                        mov     inputs,#4               &apos;ready to spatialize 4 inputs

                        rdword  t1,knobs_ptr            &apos;get knob settings

                        mov     decay,t1                &apos;get depth decay rate
                        and     decay,#7

                        shr     t1,#3                   &apos;get parallel echo level
                        neg     pecho,t1
                        and     pecho,#7        wz
        if_z            mov     pecho,#8

                        shr     t1,#3                   &apos;get cross echo level
                        neg     xecho,t1                
                        and     xecho,#7        wz                                                
        if_z            mov     xecho,#8

                        shr     t1,#3                   &apos;get dither level
                        mov     dither,t1
                        and     dither,#7
                        add     dither,#8                          

&apos; Spatialize an input channel - first update dithered outputs

:input                  mov     t1,lfsr0                &apos;update left duty output
                        sar     t1,dither    
                        add     t1,left                
                        mov     frqa,t1                  

                        mov     t1,lfsr1                &apos;update right duty output
                        sar     t1,dither
                        add     t1,right                 
                        mov     frqb,t1

&apos; Get input sample and iterate dither generators

                        rdword  lx,input_ptr    wz      &apos;get input pointer, check if 0

                        test    lfsr0,taps0     wc      &apos;iterate left dither source
                        rcl     lfsr0,#1

        if_nz           rdlong  lx,lx                   &apos;if pointer not 0, get sample, else use 0
        
                        test    lfsr1,taps1     wc      &apos;iterate right dither source
                        rcl     lfsr1,#1

&apos; Get sample into log form

                        abs     lx,lx           wc      &apos;** sample is signed value
                        muxc    sign,#1                 &apos;absolutize value and store sign

                        test    lx,hFFFF0000    wz      &apos;msb-justify value and track whole exponent 
        if_z            shl     lx,#16                  
                        muxnz   :whole,#$10

                        test    lx,hFF000000    wz
        if_z            shl     lx,#8
                        muxnz   :whole,#$08

                        test    lx,hF0000000    wz
        if_z            shl     lx,#4
                        muxnz   :whole,#$04

                        test    lx,hC0000000    wz
        if_z            shl     lx,#2
                        muxnz   :whole,#$02

                        test    lx,h80000000    wz
        if_z            shl     lx,#1
                        muxnz   :whole,#$01

                        shl     lx,#1                   &apos;lookup fractional exponent
                        movs    lx,#$C
                        rol     lx,#12
                        rdword  lx,lx
                                                                                                                                        
                        shl     lx,#16                  &apos;insert whole exponent
:whole                  or      lx,#%00000
                        ror     lx,#5                   &apos;** sample is now in log form with isolated sign

&apos; Process angle

:angle0                 mov     angle,angles            &apos;get current angle
                        rdword  t1,angle_ptr            &apos;get target angle
                        sub     t1,angle        wc      &apos;get target-current difference
                        abs     t1,t1                   &apos;absolutize difference 
                        max     t1,#$20                 &apos;limit difference
                        sumc    angle,t1                &apos;add limited difference to current angle 
:angle1                 mov     angles,angle            &apos;store current angle

                        shr     angle,#16-12            &apos;make 12-bit angle within quadrants 1|4
                        sub     angle,h00000800 wc      &apos;subtract &pi;/2, get quadrant 4 into c
                        negc    angle,angle             &apos;if quadrant 4, negate table offset
                        or      angle,h00007000         &apos;insert sine table base address &gt;&gt; 1
                        shl     angle,#1                &apos;shift left to get final word address
                        rdword  angle,angle             &apos;read sine word from table
                        negc    angle,angle             &apos;if quadrant 4, negate word (max &pm; $FFFF)
                        
&apos; Process depth

:depth0                 mov     depth,depths            &apos;get current depth
                        rdword  t1,depth_ptr            &apos;get target depth
                        shl     t1,#15                  &apos;shift up target for scaling space    
                        sub     t1,depth                &apos;get target-current difference
                        sar     t1,#19                  &apos;scale difference
:veloc0                 mov     veloc,velocs            &apos;get velocity                            
                        add     veloc,t1                &apos;add scaled difference to velocity
                        add     depth,veloc             &apos;add velocity to current depth
                        mins    depth,#0                &apos;insure current depth doesn&apos;t go negative
:depth1                 mov     depths,depth            &apos;store current depth
                        mov     t1,veloc                &apos;dampen velocity
                        sar     t1,#8                   
                        sub     veloc,t1
:veloc1                 mov     velocs,veloc            &apos;store velocity

                        shr     depth,#19-16            &apos;reduce fractional depth to 16 bits
                        
                        mov     t1,depth                &apos;attenuate sample by depth and decay rate
                        shl     t1,decay                &apos;(logarithmic curve approximates 1/d&sup2;)
                        sub     lx,t1           wc
        if_c            mov     lx,#0                   &apos;clamp underflow

                        shr     depth,#16-8             &apos;reduce fractional depth to 8 bits
                        max     depth,buff_clamp        &apos;confine depth to buffer space

&apos; Compute left and right samples with unique ear attenuations
                        
                        mov     rx,lx                   &apos;samples initially identical

                        shl     angle,#10               &apos;shift up ear sine

                        mov     t1,h04000000            &apos;attenuate left sample by left ear sine
                        add     t1,angle
                        sub     lx,t1           wc
        if_c            mov     lx,#0                   &apos;clamp underflow

                        mov     t1,h04000000            &apos;attenuate right sample by right ear sine
                        sub     t1,angle
                        sub     rx,t1           wc
        if_c            mov     rx,#0                   &apos;clamp underflow

&apos; Sum samples into left and right buffer channels at unique ear offsets

                        mov     channels,#2             &apos;ready for left and right channels

                        mov     t1,angle                &apos;multiply ear sine by 7/8 to get &lt;700&micro;s
                        sar     t1,#3                   &apos;...ear-to-ear delay (&lt;14 samples @20KHz)
                        sub     angle,t1        
                        sar     angle,#10+5             &apos;get +/- &lt;7.0 into signed 3.8 format

                        mov     t1,angle                &apos;get left ear sine (lx holds left ear sample)

:channel                add     t1,depth                &apos;get ear sine + depth (with 8 fractional bits)

                        xor     buff_base,#2            &apos;toggle left/right buffer channel

                        mov     t2,t1                   &apos;compute buffer offset for sample summing 
                        sar     t2,#8                   &apos;get ear sine + depth whole offset
                        add     t2,#8                   &apos;add center-of-head offset
                        shl     t2,#2                   &apos;convert to long offset
                        add     t2,buff_ptr             &apos;add buffer pointer
                        cmpsub  t2,buff_size            &apos;insure buffer wrap
                        cmp     t2,buff_limit   wz      &apos;remember if last location
                        add     t2,buff_base            &apos;add buffer base with left/right channel

                        rol     lx,#5                   &apos;** sample is in log form with isolated sign
                        movs    :shr,lx                 &apos;get whole log
                        xor     :shr,#$1F               &apos;not whole log
                        movs    lx,#$D                  &apos;use fractional log to lookup antilog
                        rol     lx,#12
                        rdword  lx,lx
                        shl     lx,#15                  &apos;msb-justify antilog with leading 1
                        or      lx,h80000000
:shr                    shr     lx,#0                   &apos;shift antilog down by not whole log
                        test    sign,#1         wc      &apos;restore sign
                        negc    lx,lx                   &apos;** sample is now signed value

                        mov     t3,lx                   &apos;get whole sample

                        sar     lx,#8                   &apos;compute fractional sample for precise      
                        shl     lx,#8-1                 &apos;...inter-sample summation
                        and     t1,#$FF                 &apos;(uses 8 fractional bits of ear sine + depth)   
                        shr     t1,#1           wc
        if_c            add     t1,lx
                        sar     t1,#1           wc
        if_c            add     t1,lx
                        sar     t1,#1           wc
        if_c            add     t1,lx                                                              
                        sar     t1,#1           wc                                                 
        if_c            add     t1,lx                                                              
                        sar     t1,#1           wc
        if_c            add     t1,lx
                        sar     t1,#1           wc
        if_c            add     t1,lx
                        sar     t1,#1           wc
        if_c            add     t1,lx
                        sar     t1,#1           wc
        if_c            add     t1,lx

                        sub     t3,t1                   &apos;get whole-minus-fractional sample            

                        rdword  lx,t2                   &apos;sum whole-minus-fractional sample into +0
                        shr     t3,#16
                        add     lx,t3
                        wrword  lx,t2

        if_nz           add     t2,#4                   &apos;increment buffer offset
        if_z            mov     t2,buff_base            &apos;insure buffer wrap

                        rdword  lx,t2                   &apos;sum fractional sample into +1
                        shr     t1,#16
                        add     lx,t1
                        wrword  lx,t2
                        
                        mov     lx,rx                   &apos;get right ear sample
                        neg     t1,angle                &apos;get right ear sine
                        
                        djnz    channels,#:channel      &apos;loop once for right channel

&apos; Another input channel?

                        add     input_ptr,#2            &apos;increment pointers
                        add     angle_ptr,#2
                        add     depth_ptr,#2
                        add     :angle0,#1
                        add     :angle1,h00000200
                        add     :depth0,#1
                        add     :depth1,h00000200
                        add     :veloc0,#1
                        add     :veloc1,h00000200

                        djnz    inputs,#:input          &apos;another input channel?

                        sub     input_ptr,#4*2          &apos;done, reset pointers                                 
                        sub     depth_ptr,#4*2
                        sub     angle_ptr,#4*2
                        sub     :angle0,#4
                        sub     :angle1,h00000800
                        sub     :depth0,#4
                        sub     :depth1,h00000800
                        sub     :veloc0,#4
                        sub     :veloc1,h00000800

&apos; Read output samples from buffer and write echoes back

                        mov     t1,buff_ptr             &apos;read sample pair from buffer
                        add     t1,buff_base
                        rdlong  left,t1

                        add     buff_ptr,#4             &apos;advance buffer pointer
                        cmpsub  buff_ptr,buff_size      &apos;insure buffer wrap

                        wrlong  left,par                &apos;update sample pair in main memory

                        mov     right,left              &apos;unpack left and right samples
                        shl     right,#16
                        and     left,hFFFF0000

                        mov     lx,left                 &apos;compute parallel echoes
                        sar     lx,pecho
                        mov     rx,right
                        sar     rx,pecho

                        mov     t2,right                &apos;compute cross echoes
                        sar     t2,xecho
                        add     lx,t2
                        mov     t2,left
                        sar     t2,xecho
                        add     rx,t2

                        add     left,h80000000          &apos;convert samples to duty cycles
                        add     right,h80000000                       

                        and     lx,hFFFF0000            &apos;write echoes back to buffer
                        shr     rx,#16                  
                        or      lx,rx
                        wrlong  lx,t1

&apos; Loop for next sample period

                        jmp     #loop
                                

&apos; &boxdr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdl;
&apos; &boxv;  Defined Data  &boxv;
&apos; &boxur;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxul;

hFFFF0000               long    $FFFF0000               &apos;miscellaneous constants greater than 9 bits
hFF000000               long    $FF000000
hF0000000               long    $F0000000
hC0000000               long    $C0000000
h80000000               long    $80000000
h10000000               long    $10000000
h04000000               long    $04000000
h00007000               long    $00007000
h00000800               long    $00000800
h00000200               long    $00000200

lfsr0                   long    1                       &apos;linear feedback shift registers for dither noise
taps0                   long    $A4000080               
lfsr1                   long    1                       
taps1                   long    $80A01000               

clear_cnt               long    $1F0 - reserves         &apos;number of reserved registers to clear on startup


&apos; &boxdr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdl;
&apos; &boxv;  Undefined Data (zeroed by initialization code)  &boxv;
&apos; &boxur;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxul;

reserves

cnt_value               res     1                       &apos;reserved registers that get cleared on startup
cnt_ticks               res     1                        

buff_base               res     1
buff_size               res     1
buff_limit              res     1
buff_clamp              res     1
buff_ptr                res     1

input_ptr               res     1
angle_ptr               res     1
depth_ptr               res     1
knobs_ptr               res     1

decay                   res     1
pecho                   res     1
xecho                   res     1
dither                  res     1
                                    
sign                    res     1
inputs                  res     1
channels                res     1

angle                   res     1
depth                   res     1
veloc                   res     1

angles                  res     4
depths                  res     4
velocs                  res     4

t1                      res     1
t2                      res     1
t3                      res     1

lx                      res     1
rx                      res     1

left                    res     1
right                   res     1

{{

&boxdr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdl;
&boxv;                                                   TERMS OF USE: MIT License                                                  &boxv;                                                            
&boxvr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxvl;
&boxv;Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation    &boxv; 
&boxv;files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy,    &boxv;
&boxv;modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software&boxv;
&boxv;is furnished to do so, subject to the following conditions:                                                                   &boxv;
&boxv;                                                                                                                              &boxv;
&boxv;The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.&boxv;
&boxv;                                                                                                                              &boxv;
&boxv;THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE          &boxv;
&boxv;WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR         &boxv;
&boxv;COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,   &boxv;
&boxv;ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                         &boxv;
&boxur;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxul;
}}
    </code></pre>

    <pre><code>
{{
&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;
File: Parallax Serial Terminal.spin
Version: 1.0
Copyright (c) 2009 Parallax, Inc.
See end of file for terms of use.

Authors: Jeff Martin, Andy Lindsay, Chip Gracey  
&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;
}}

{
HISTORY:
    This object is made for direct use with the Parallax Serial Terminal; a simple serial communication program
    available with the Propeller Tool installer and also separately via the Parallax website (www.parallax.com).

    This object is heavily based on FullDuplexSerialPlus (by Andy Lindsay), which is itself heavily based on
    FullDuplexSerial (by Chip Gracey).

USAGE:
    &bull; Call Start, or StartRxTx, first.
    &bull; Be sure to set the Parallax Serial Terminal software to the baudrate specified in Start, and the proper COM port.
    &bull; At 80 MHz, this object properly receives/transmits at up to 250 Kbaud, or performs transmit-only at up to 1 Mbaud.
    
}
    
CON
&apos;&apos;
&apos;&apos;     Parallax Serial Terminal
&apos;&apos;    Control Character Constants
&apos;&apos;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;
    CS = 16  &apos;&apos;CS: Clear Screen      
    CE = 11  &apos;&apos;CE: Clear to End of line     
    CB = 12  &apos;&apos;CB: Clear lines Below 

    HM =  1  &apos;&apos;HM: HoMe cursor       
    PC =  2  &apos;&apos;PC: Position Cursor in x,y          
    PX = 14  &apos;&apos;PX: Position cursor in X         
    PY = 15  &apos;&apos;PY: Position cursor in Y         

    NL = 13  &apos;&apos;NL: New Line        
    LF = 10  &apos;&apos;LF: Line Feed       
    ML =  3  &apos;&apos;ML: Move cursor Left          
    MR =  4  &apos;&apos;MR: Move cursor Right         
    MU =  5  &apos;&apos;MU: Move cursor Up          
    MD =  6  &apos;&apos;MD: Move cursor Down
    TB =  9  &apos;&apos;TB: TaB          
    BS =  8  &apos;&apos;BS: BackSpace          
            
    BP =  7  &apos;&apos;BP: BeeP speaker          

CON

    BUFFER_LENGTH = 64                                   &apos;Recommended as 64 or higher, but can be 2, 4, 8, 16, 32, 64, 128 or 256.
    BUFFER_MASK   = BUFFER_LENGTH - 1
    MAXSTR_LENGTH = 49                                   &apos;Maximum length of received numerical string (not including zero terminator).

VAR

    long  cog                                             &apos;Cog flag/id

    long  rx_head                                         &apos;9 contiguous longs (must keep order)
    long  rx_tail
    long  tx_head
    long  tx_tail
    long  rx_pin
    long  tx_pin
    long  rxtx_mode
    long  bit_ticks
    long  buffer_ptr
                        
    byte  rx_buffer[BUFFER_LENGTH]                        &apos;Receive and transmit buffers
    byte  tx_buffer[BUFFER_LENGTH]

    byte  str_buffer[MAXSTR_LENGTH+1]                     &apos;String buffer for numerical strings

PUB Start(baudrate) : okay
{{Start communication with the Parallax Serial Terminal using the Propeller&apos;s programming connection.
Waits 1 second for connection, then clears screen.
    Parameters:
    baudrate - bits per second.  Make sure it matches the Parallax Serial Terminal&apos;s
                Baud Rate field.
    Returns    : True (non-zero) if cog started, or False (0) if no cog is available.}}

    okay := StartRxTx(31, 30, 0, baudrate)
    waitcnt(clkfreq + cnt)                                &apos;Wait 1 second for PST
    Clear                                                 &apos;Clear display

PUB StartRxTx(rxpin, txpin, mode, baudrate) : okay
{{Start serial communication with designated pins, mode, and baud.
    Parameters:
    rxpin    - input pin; receives signals from external device&apos;s TX pin.
    txpin    - output pin; sends signals to  external device&apos;s RX pin.
    mode     - signaling mode (4-bit pattern).
                bit 0 - inverts rx.
                bit 1 - inverts tx.
                bit 2 - open drain/source tx.
                bit 3 - ignore tx echo on rx.
    baudrate - bits per second.
    Returns    : True (non-zero) if cog started, or False (0) if no cog is available.}}

    stop
    longfill(@rx_head, 0, 4)
    longmove(@rx_pin, @rxpin, 3)
    bit_ticks := clkfreq / baudrate
    buffer_ptr := @rx_buffer
    okay := cog := cognew(@entry, @rx_head) + 1

PUB Stop
{{Stop serial communication; frees a cog.}}

    if cog
    cogstop(cog~ - 1)
    longfill(@rx_head, 0, 9)

PUB Char(bytechr)
{{Send single-byte character.  Waits for room in transmit buffer if necessary.
    Parameter:
    bytechr - character (ASCII byte value) to send.}}

    repeat until (tx_tail &lt;&gt; ((tx_head + 1) &amp; BUFFER_MASK))
    tx_buffer[tx_head] := bytechr
    tx_head := (tx_head + 1) &amp; BUFFER_MASK

    if rxtx_mode &amp; %1000
    CharIn

PUB Chars(bytechr, count)
{{Send multiple copies of a single-byte character. Waits for room in transmit buffer if necessary.
    Parameters:
    bytechr - character (ASCII byte value) to send.
    count   - number of bytechrs to send.}}

    repeat count
    Char(bytechr)

PUB CharIn : bytechr
{{Receive single-byte character.  Waits until character received.
    Returns: $00..$FF}}

    repeat while (bytechr := RxCheck) &lt; 0

PUB Str(stringptr)
{{Send zero terminated string.
    Parameter:
    stringptr - pointer to zero terminated string to send.}}

    repeat strsize(stringptr)
    Char(byte[stringptr++])

PUB StrIn(stringptr)
{{Receive a string (carriage return terminated) and stores it (zero terminated) starting at stringptr.
Waits until full string received.
    Parameter:
    stringptr - pointer to memory in which to store received string characters.
                Memory reserved must be large enough for all string characters plus a zero terminator.}}
    
    StrInMax(stringptr, -1)

PUB StrInMax(stringptr, maxcount)
{{Receive a string of characters (either carriage return terminated or maxcount in length) and stores it (zero terminated)
starting at stringptr.  Waits until either full string received or maxcount characters received.
    Parameters:
    stringptr - pointer to memory in which to store received string characters.
                Memory reserved must be large enough for all string characters plus a zero terminator (maxcount + 1).
    maxcount  - maximum length of string to receive, or -1 for unlimited.}}
    
    repeat while (maxcount--)                                                     &apos;While maxcount not reached
    if (byte[stringptr++] := CharIn) == NL                                      &apos;Get chars until NL
        quit
    byte[stringptr+(byte[stringptr-1] == NL)]~                                    &apos;Zero terminate string; overwrite NL or append 0 char

PUB Dec(value) | i, x
{{Send value as decimal characters.
    Parameter:
    value - byte, word, or long value to send as decimal characters.}}

    x := value == NEGX                                                            &apos;Check for max negative
    if value &lt; 0
    value := ||(value+x)                                                        &apos;If negative, make positive; adjust for max negative
    Char(&quot;-&quot;)                                                                   &apos;and output sign

    i := 1_000_000_000                                                            &apos;Initialize divisor

    repeat 10                                                                     &apos;Loop for 10 digits
    if value =&gt; i                                                               
        Char(value / i + &quot;0&quot; + x*(i == 1))                                        &apos;If non-zero digit, output digit; adjust for max negative
        value //= i                                                               &apos;and digit from value
        result~~                                                                  &apos;flag non-zero found
    elseif result or i == 1
        Char(&quot;0&quot;)                                                                 &apos;If zero digit (or only digit) output it
    i /= 10                                                                     &apos;Update divisor

PUB DecIn : value
{{Receive carriage return terminated string of characters representing a decimal value.
    Returns: the corresponding decimal value.}}

    StrInMax(@str_buffer, MAXSTR_LENGTH)
    value := StrToBase(@str_buffer, 10)

PUB Bin(value, digits)
{{Send value as binary characters up to digits in length.
    Parameters:
    value  - byte, word, or long value to send as binary characters.
    digits - number of binary digits to send.  Will be zero padded if necessary.}}

    value &lt;&lt;= 32 - digits
    repeat digits
    Char((value &lt;-= 1) &amp; 1 + &quot;0&quot;)

PUB BinIn : value
{{Receive carriage return terminated string of characters representing a binary value.
    Returns: the corresponding binary value.}}
    
    StrInMax(@str_buffer, MAXSTR_LENGTH)
    value := StrToBase(@str_buffer, 2)
    
PUB Hex(value, digits)
{{Send value as hexadecimal characters up to digits in length.
    Parameters:
    value  - byte, word, or long value to send as hexadecimal characters.
    digits - number of hexadecimal digits to send.  Will be zero padded if necessary.}}

    value &lt;&lt;= (8 - digits) &lt;&lt; 2
    repeat digits
    Char(lookupz((value &lt;-= 4) &amp; $F : &quot;0&quot;..&quot;9&quot;, &quot;A&quot;..&quot;F&quot;))

PUB HexIn : value
{{Receive carriage return terminated string of characters representing a hexadecimal value.
    Returns: the corresponding hexadecimal value.}}

    StrInMax(@str_buffer, MAXSTR_LENGTH)
    value := StrToBase(@str_buffer, 16)

PUB Clear
{{Clear screen and place cursor at top-left.}}
    
    Char(CS)

PUB ClearEnd
{{Clear line from cursor to end of line.}}
    
    Char(CE)
    
PUB ClearBelow
{{Clear all lines below cursor.}}
    
    Char(CB)
    
PUB Home
{{Send cursor to home position (top-left).}}
    
    Char(HM)
    
PUB Position(x, y)
{{Position cursor at column x, row y (from top-left).}}
    
    Char(PC)
    Char(x)
    Char(y)
    
PUB PositionX(x)
{{Position cursor at column x of current row.}}
    Char(PX)
    Char(x)
    
PUB PositionY(y)
{{Position cursor at row y of current column.}}
    Char(PY)
    Char(y)

PUB NewLine
{{Send cursor to new line (carriage return plus line feed).}}
    
    Char(NL)
    
PUB LineFeed
{{Send cursor down to next line.}}
    
    Char(LF)
    
PUB MoveLeft(x)
{{Move cursor left x characters.}}
    
    repeat x
    Char(ML)
    
PUB MoveRight(x)
{{Move cursor right x characters.}}
    
    repeat x
    Char(MR)
    
PUB MoveUp(y)
{{Move cursor up y lines.}}
    
    repeat y
    Char(MU)
    
PUB MoveDown(y)
{{Move cursor down y lines.}}
    
    repeat y
    Char(MD)
    
PUB Tab
{{Send cursor to next tab position.}}
    
    Char(TB)
    
PUB Backspace
{{Delete one character to left of cursor and move cursor there.}}
    
    Char(BS)
    
PUB Beep
{{Play bell tone on PC speaker.}}
    
    Char(BP)
    
PUB RxCount : count
{{Get count of characters in receive buffer.
    Returns: number of characters waiting in receive buffer.}}

    count := rx_head - rx_tail
    count -= BUFFER_LENGTH*(count &lt; 0)

PUB RxFlush
{{Flush receive buffer.}}

    repeat while rxcheck =&gt; 0
    
PRI RxCheck : bytechr
{Check if character received; return immediately.
    Returns: -1 if no byte received, $00..$FF if character received.}

    bytechr~~
    if rx_tail &lt;&gt; rx_head
    bytechr := rx_buffer[rx_tail]
    rx_tail := (rx_tail + 1) &amp; BUFFER_MASK

PRI StrToBase(stringptr, base) : value | chr, index
{Converts a zero terminated string representation of a number to a value in the designated base.
Ignores all non-digit characters (except negative (-) when base is decimal (10)).}

    value := index := 0
    repeat until ((chr := byte[stringptr][index++]) == 0)
    chr := -15 + --chr &amp; %11011111 + 39*(chr &gt; 56)                              &apos;Make &quot;0&quot;-&quot;9&quot;,&quot;A&quot;-&quot;F&quot;,&quot;a&quot;-&quot;f&quot; be 0 - 15, others out of range     
    if (chr &gt; -1) and (chr &lt; base)                                              &apos;Accumulate valid values into result; ignore others
        value := value * base + chr                                                  
    if (base == 10) and (byte[stringptr] == &quot;-&quot;)                                  &apos;If decimal, address negative sign; ignore otherwise
    value := - value
        
DAT

&apos;***********************************
&apos;* Assembly language serial driver *
&apos;***********************************

                        org
&apos;
&apos;
&apos; Entry
&apos;
entry                   mov     t1,par                &apos;get structure address
                        add     t1,#4 &lt;&lt; 2            &apos;skip past heads and tails

                        rdlong  t2,t1                 &apos;get rx_pin
                        mov     rxmask,#1
                        shl     rxmask,t2

                        add     t1,#4                 &apos;get tx_pin
                        rdlong  t2,t1
                        mov     txmask,#1
                        shl     txmask,t2

                        add     t1,#4                 &apos;get rxtx_mode
                        rdlong  rxtxmode,t1

                        add     t1,#4                 &apos;get bit_ticks
                        rdlong  bitticks,t1

                        add     t1,#4                 &apos;get buffer_ptr
                        rdlong  rxbuff,t1
                        mov     txbuff,rxbuff
                        add     txbuff,#BUFFER_LENGTH

                        test    rxtxmode,#%100  wz    &apos;init tx pin according to mode
                        test    rxtxmode,#%010  wc
        if_z_ne_c       or      outa,txmask
        if_z            or      dira,txmask

                        mov     txcode,#transmit      &apos;initialize ping-pong multitasking
&apos;
&apos;
&apos; Receive
&apos;
receive                 jmpret  rxcode,txcode         &apos;run chunk of tx code, then return

                        test    rxtxmode,#%001  wz    &apos;wait for start bit on rx pin
                        test    rxmask,ina      wc
        if_z_eq_c       jmp     #receive

                        mov     rxbits,#9             &apos;ready to receive byte
                        mov     rxcnt,bitticks
                        shr     rxcnt,#1
                        add     rxcnt,cnt                          

:bit                    add     rxcnt,bitticks        &apos;ready next bit period

:wait                   jmpret  rxcode,txcode         &apos;run chunk of tx code, then return

                        mov     t1,rxcnt              &apos;check if bit receive period done
                        sub     t1,cnt
                        cmps    t1,#0           wc
        if_nc           jmp     #:wait

                        test    rxmask,ina      wc    &apos;receive bit on rx pin
                        rcr     rxdata,#1
                        djnz    rxbits,#:bit

                        shr     rxdata,#32-9          &apos;justify and trim received byte
                        and     rxdata,#$FF
                        test    rxtxmode,#%001  wz    &apos;if rx inverted, invert byte
        if_nz           xor     rxdata,#$FF

                        rdlong  t2,par                &apos;save received byte and inc head
                        add     t2,rxbuff
                        wrbyte  rxdata,t2
                        sub     t2,rxbuff
                        add     t2,#1
                        and     t2,#BUFFER_MASK
                        wrlong  t2,par

                        jmp     #receive              &apos;byte done, receive next byte
&apos;
&apos;
&apos; Transmit
&apos;
transmit                jmpret  txcode,rxcode         &apos;run chunk of rx code, then return

                        mov     t1,par                &apos;check for head &lt;&gt; tail
                        add     t1,#2 &lt;&lt; 2
                        rdlong  t2,t1
                        add     t1,#1 &lt;&lt; 2
                        rdlong  t3,t1
                        cmp     t2,t3           wz
        if_z            jmp     #transmit

                        add     t3,txbuff             &apos;get byte and inc tail
                        rdbyte  txdata,t3
                        sub     t3,txbuff
                        add     t3,#1
                        and     t3,#BUFFER_MASK
                        wrlong  t3,t1

                        or      txdata,#$100          &apos;ready byte to transmit
                        shl     txdata,#2
                        or      txdata,#1
                        mov     txbits,#11
                        mov     txcnt,cnt

:bit                    test    rxtxmode,#%100  wz    &apos;output bit on tx pin 
                        test    rxtxmode,#%010  wc    &apos;according to mode
        if_z_and_c      xor     txdata,#1
                        shr     txdata,#1       wc
        if_z            muxc    outa,txmask        
        if_nz           muxnc   dira,txmask
                        add     txcnt,bitticks        &apos;ready next cnt

:wait                   jmpret  txcode,rxcode         &apos;run chunk of rx code, then return

                        mov     t1,txcnt              &apos;check if bit transmit period done
                        sub     t1,cnt
                        cmps    t1,#0           wc
        if_nc           jmp     #:wait

                        djnz    txbits,#:bit          &apos;another bit to transmit?

                        jmp     #transmit             &apos;byte done, transmit next byte
&apos;
&apos;
&apos; Uninitialized data
&apos;
t1                      res     1
t2                      res     1
t3                      res     1

rxtxmode                res     1
bitticks                res     1

rxmask                  res     1
rxbuff                  res     1
rxdata                  res     1
rxbits                  res     1
rxcnt                   res     1
rxcode                  res     1

txmask                  res     1
txbuff                  res     1
txdata                  res     1
txbits                  res     1
txcnt                   res     1
txcode                  res     1

{{

&boxdr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdl;
&boxv;                           TERMS OF USE: MIT License                                  &boxv;                                                            
&boxvr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxvl;
&boxv;Permission is hereby granted, free of charge, to any person obtaining a copy of this  &boxv;
&boxv;software and associated documentation files (the &quot;Software&quot;), to deal in the Software &boxv; 
&boxv;without restriction, including without limitation the rights to use, copy, modify,    &boxv;
&boxv;merge, publish, distribute, sublicense, and/or sell copies of the Software, and to    &boxv;
&boxv;permit persons to whom the Software is furnished to do so, subject to the following   &boxv;
&boxv;conditions:                                                                           &boxv;                                            &boxv;
&boxv;                                                                                      &boxv;                                               &boxv;
&boxv;The above copyright notice and this permission notice shall be included in all copies &boxv;
&boxv;or substantial portions of the Software.                                              &boxv;
&boxv;                                                                                      &boxv;                                                &boxv;
&boxv;THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,   &boxv;
&boxv;INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A         &boxv;
&boxv;PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT    &boxv;
&boxv;HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION     &boxv;
&boxv;OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE        &boxv;
&boxv;SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                                &boxv;
&boxur;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxul;
}}
    </code></pre>
    <pre><code>
CON
{{                                                                           
    #############   ###############   ###############   #############          
    #############   ###############   ###############   #############          
  ###############   ###############   ###############   ###############        
  ###############   ###############   ###############   ###############        
  ####              ####       ####         ###         ####       ####        
  ####              ####       ####         ###         ####       ####        
  ###############   ####       ####         ###         ####       ####        
  ###############   ###############         ###         ####       ####        
  ###############   ###############         ###         ####       ####        
             ####   #############           ###         ####       ####        
             ####   #############           ###         ####       ####        
  ###############   ####              ###############   ####       ####        
  ###############   ####              ###############   ####       ####        
  #############     ####              ###############   ####       ####        
  #############     ####              ###############   ####       ####        
                                                                               
                                                                               
                ##    ## ######## ##    ##  ####### ########  ####### #######  
                ##    ## ######## ##    ## ######## ######## ######## ######## 
                ##    ## ##       ##    ## ##    ## ##       ##    ## ##    ## 
                ######## ########  ######  ##    ## ##    ## ##    ## ##    ## 
                ######## ########  ######  ######## ##    ## ##    ## ##    ## 
                ##    ## ##       ##    ## ######## ##    ## ##    ## ##    ## 
                ##    ## ######## ##    ## ##    ## ######## ######## ##    ## 
                ##    ##  ####### ##    ## ##    ## #######  #######  ##    ## 

Release Candidate 4
                
2020 IRQsome Software
Distributed under permission from Terry Cavanagh

Original by Terry Cavanagh
Music by Chipzel
Voice by Jenn Frank

}}                                                                               








_clkmode = xtal1 + pll16x
_xinfreq = 5_000_000
_stack   = 200



CHEATZ = 0 &apos; 0 for no cheats, 1 for minor cheats, 2 for noclip






 SCANLINE_BUFFER = gfx#SCANLINE_BUFFER
  NUM_LINES = gfx#NUM_LINES
                                               
 border_color                   = gfx#border_color &apos; border color
 displaylist_adr                = gfx#displaylist_adr &apos;pointer to display list
 displaylist_in_use             = gfx#displaylist_in_use &apos;display list adress feedback

 END_OF_DRIVER_RESERVED = gfx#MEMORY_END

 DLIST_SIZE = 640 &apos; longs

 _free    = ($8000-END_OF_DRIVER_RESERVED+3)/4   

OBJ

gfx : &quot;VJET_v00_composite_wrapper_xasm.spin&quot;
kb  : &quot;Keyboard_xasm.spin&quot;
pst: &quot;DummyPST&quot;&apos;}&quot;Parallax Serial Terminal&quot;
gl  : &quot;VJET_v00_displaylist.spin&quot; 
font: &quot;hexfont.spin&quot;
sdda: &quot;hexagon_sdda.spin&quot;
plat: &quot;platform.spin&quot;

DAT &apos;&apos; pretend this is a VAR (non-zero-initialized variables and some byte/word wide ones go here to help make fastspin happy)
org
random long 42

color1 word $0202
color2 word $0202 
color3 word $0202

sector_angles word 0*(8192/SECTORS),1*(8192/SECTORS),2*(8192/SECTORS),3*(8192/SECTORS),4*(8192/SECTORS),5*(8192/SECTORS)

stage byte 0
state byte TITLE

safe_colors byte false &apos; change to true when using S-Video (disables $x8 colors)

firstplay_flag byte 0
current_music byte -1

strbuf_hi byte 0[8] &apos; current stage hiscore string buffer

strbuf_frames byte 0[4] &apos; current timer string buffers  
strbuf_secs byte 0[4]

strbuf2_frames byte 0[4]
strbuf2_secs byte 0[4] &apos; misc.

DAT &apos;&apos; some lookup tables and strings

leveltimetbl word
word  0*60 &apos; Point
word 10*60 &apos; Line
word 20*60 &apos; Triangle
word 30*60 &apos; Square
word 45*60 &apos; Pentagon
word 60*60 &apos; Hexagon
word 0 &apos; convenient zero

levelstringtbl word 
word @point_str
word @line_str
word @triangle_str
word @square_str
word @pentagon_str
word @hexagon_str

stagestringtbl word 
word @hexagon_str
word @hexagoner_str
word @hexagonest_str
word @hexagon_str
word @hexagoner_str
word @hexagonest_str
word @blackwhite_str

stagedifficultytbl word 
word @hard_str
word @harder_str
word @hardest_str
word @hardester_str
word @hardestest_str
word @hardestestest_str
word @hexagon_str

stage2effstage_tbl byte
byte EFF_HEXAGON1,EFF_HEXAGONER1,EFF_HEXAGONEST1,EFF_HEXAGON2,EFF_HEXAGONER2,EFF_HEXAGONEST2,EFF_BLACKWHITE

new_record_str byte &quot;NEW &quot;
record_str byte &quot;RECORD!&quot;,0
hyper_str byte &quot;HYPER&quot;,0

DAT
long
org
save_space
stage_records long 0[STAGE_COUNT]
long 0[sdda#SAVE_SIZE-STAGE_COUNT] &apos;reserve some data

org
dlist_space &apos;&apos; Display lists overwrite cog PASM
render_asm file &quot;VJET_v00_rendering.dat&quot;
tv_asm file &quot;VJET_v00_composite.dat&quot;
sdda_asm file &quot;tinySDDA.dat&quot;
keyboard_asm file &quot;Keyboard.dat&quot;

long $00[DLIST_SIZE*2-$]
    
VAR       

long state_timer, game_timer
word script_timer &apos; the wait times are limited to 15 bits, anyways

long view_scale_y,center_x,center_y
word player_angle 
long playfield_speed
word playfield_rotation

byte effectivestage
byte hitflag
byte playfield_colorswap
byte player_sector
byte colorswap_timer            

long wall_phase
byte wall_spawnpos

word wall_speed,player_speed
long speed_target &apos; for playfield_speed


word fontptr,subcodeptr

long next_pattern
word patternlist

word script_pc  

byte overflow_flag,commit_record_flag,gameover_newrecord_flag

long framecount
long snes_prev

long polybuf[SECTORS*2*4]
long sector_vx[SECTORS],sector_vy[SECTORS]

&apos;long sector_walls[SECTORS*WALLBUFFER_SIZE]
&apos;long walls_low[SECTORS],walls_high[SECTORS]
byte _dummy,wallbitmap[WALLBUFFER_SIZE]


word dlist1ptr,dlist2ptr


&apos;long dlist1[DLIST_SIZE],dlist2[DLIST_SIZE]

CON &apos;&apos; Enumerations
 #0,HEXAGON,HEXAGONER,HEXAGONEST,HYPER_HEXAGON,HYPER_HEXAGONER,HYPER_HEXAGONEST,BLACKWHITE,STAGE_COUNT 

 #0,EFF_TITLE,EFF_HEXAGON1,EFF_HEXAGON2,EFF_HEXAGON3,EFF_HEXAGONER1,EFF_HEXAGONER2,EFF_HEXAGONER3,EFF_HEXAGONEST1,EFF_HEXAGONEST2,EFF_BLACKWHITE

 #0,TITLE,LEVELSELECT,PLAY,GAMEOVER


PUB main

init
repeat     
  do_frame
  
PRI do_frame | tmp

  gfx.Wait_Vsync
  if overflow_flag~
    tmp:=$CC
  else
    tmp:=$2D
  word[border_color]:=tmp
  ifnot framecount&amp;1
    word[displaylist_adr] := dlist1ptr
    gl.start(dlist2ptr,constant(DLIST_SIZE*4)) 
  else
    word[displaylist_adr] := dlist2ptr
    gl.start(dlist1ptr,constant(DLIST_SIZE*4))
  framecount++
  &apos;framecount &amp;= $1f
  &apos;longmove(current_dlist,@testdlist,128) 
  
  update
  if tmp := \draw
    pst.str(string(&quot;ABORT &quot;))
    pst.dec(tmp)
    pst.newline

  if tmp:=gl.done
    overflow_flag~~
    pst.str(string(&quot;DLIST OVRFLOW: &quot;))
    pst.dec(tmp)
    pst.newline
   
  
  &apos;pst.str(string(&quot;onek &quot;))
  &apos;pst.hex(framecount,8)
  &apos;pst.newline
  word[border_color]:=$04
  &apos;word[@testdlist][1] := 50+(sin(framecount*63)/2048)
  &apos;word[@testdlist][2] := word[@testdlist][1]+20

PRI init
pst.start(115_200)

if sdda.unstash
  subcodeptr:= sdda.sdda_start(@sdda_asm)
else
  subcodeptr:= $8080

&apos; try loading the saved records - remains zero-initialized otherwise
sdda.readsavedata(@save_space)


kb.startx(plat#PS2_DATA,plat#PS2_CLOCK,%0_111_001, %11_11111,@keyboard_asm)
 
word[displaylist_adr] := $8080
&apos;&apos;set up graphics driver
gfx.start(plat#TV_PINGROUP,4,@render_asm,@tv_asm) &apos;start graphics driver

dlist1ptr := @dlist_space
dlist2ptr := @dlist_space+constant(DLIST_SIZE*4)
longfill(@dlist_space,0,constant(DLIST_SIZE*2)) &apos; this is neccessary to make sure the graphics cogs don&apos;t go off the deep end

gl.set_clip(0,gfx#HEIGHT&lt;&lt;16,0,gfx#WIDTH&lt;&lt;16)

fontptr := font.get

clearwalls
  
CON

  PRESCALE_SHL = 6
  PRESCALE = |&lt;PRESCALE_SHL

  PIXEL_ASPECT = 35.5/28.0 &apos;&apos; Aspect ratio of a pixel - empircal measurement
  VIRTUAL_WIDTH = float(gfx#WIDTH)*PIXEL_ASPECT
  VIRTUAL_HEIGHT = float(gfx#HEIGHT)
  PIXEL_ASPECT_FIX  = round(float(posx)/PIXEL_ASPECT)
  
  SECTORS = 6
  WALLBUFFER_SIZE = 48

  WALL_PARKED = negx/2

  PLAYFIELD_RADIUS = 1024


  PATTERN_UNIT = 16

  PATTERN_PTR_MASK = $F_FFFF &apos; P2 ready!
  PATTERN_CW       = 0
  PATTERN_CCW      = |&lt;31
  PATTERN_OFFSET_SHIFT = 28
  PATTERN_OFFSET_MASK = $7
  PATTERN_WEIGHT_SHIFT = 20
  PATTERN_WEIGHT_MASK = $FF
  OFFSET_RANDOMIZE  = 6
  OFFSET_RANDOMIZE2 = 7 &apos;also randomize direction

  SPEED_SMOOTHING = 6
  
  
  HEXAGON1_RADIUS_UNSCALED = 22 &apos; measured
  HEXAGON1_RADIUS = HEXAGON1_RADIUS_UNSCALED * PRESCALE 
  PLAYER_RADIUS_UNSCALED = 28 &apos; measured
  PLAYER_RADIUS = PLAYER_RADIUS_UNSCALED * PRESCALE
  PLAYER_RADIUS_WALLSPACE = $10000*(PLAYER_RADIUS_UNSCALED-HEXAGON1_RADIUS_UNSCALED)/WALL_UNIT_UNSCALED 
  WALL_UNIT_UNSCALED = 16
  WALL_UNIT = WALL_UNIT_UNSCALED * PRESCALE 
  TEST1_RADIUS = 64 * PRESCALE

  PLAYER_RADIUS_INNER = float(PLAYER_RADIUS_UNSCALED)*((^^3.0)/2.0)
  WALLDRAW_RADIUS = trunc(^^((VIRTUAL_WIDTH*VIRTUAL_WIDTH+VIRTUAL_HEIGHT*VIRTUAL_HEIGHT)/4.0)-PLAYER_RADIUS_INNER+float(PLAYER_RADIUS_UNSCALED))&apos;200
  WALLDRAW_MAX = WALLDRAW_RADIUS/WALL_UNIT_UNSCALED+2

  WALLSPAWN_MAX = 15 &apos; should be larger than WALLDRAW_MAX to avoid pop-in
   
PRI clearwalls
&apos;longfill(@sector_walls,WALL_PARKED,SECTORS*WALLBUFFER_SIZE)
&apos;wall_phase := $D0000

&apos;longfill(@walls_low,0,constant(SECTORS*2)) &apos; fill both walls_low and walls_high
bytefill(@wallbitmap,0,WALLBUFFER_SIZE)
wall_phase := 0
wall_spawnpos := WALLSPAWN_MAX

{PRI testwalls | i
clearwalls
repeat i from 0 to constant(WALLBUFFER_SIZE-1)
  &apos;wallbitmap[i] |= ($99 &lt;&lt; (i&amp;1))&amp;$1F
   wallbitmap[i] := $49249249 &gt;&gt; i

}

PRI try_spawn_pattern |i,tmp,wptr,offset,ccw,size

&apos;pst.str(string(13,&quot;Attempting spawn... &quot;))
&apos;pst.dec(wall_spawnpos)
&apos;pst.char(&quot; &quot;)
&apos;pst.hex(next_pattern,4)
&apos;pst.char(&quot; &quot;)

if wall_spawnpos =&gt; WALLSPAWN_MAX &apos; don&apos;t spawn too far ahead
  return
wptr := next_pattern&apos;&amp;PATTERN_PTR_MASK
&apos;pst.str(string(&quot;okay... &quot;))
if (size:=byte[wptr++]) + wall_spawnpos =&gt; WALLBUFFER_SIZE &apos; check if there are enough free slots
  return
&apos;pst.str(string(&quot;WE&apos;RE IN! &quot;))
&apos; prepare
offset := (next_pattern&gt;&gt;PATTERN_OFFSET_SHIFT)&amp;PATTERN_OFFSET_MASK
ccw:=next_pattern &amp; PATTERN_CCW

if offset =&gt; OFFSET_RANDOMIZE
  if offset =&gt; OFFSET_RANDOMIZE2
    if (random?)&amp;4
      NOT ccw
  offset := (random?&amp;posx)//SECTORS

pst.dec(offset)

if ccw &apos; Adjust offset for CCW so sector 0 stays sector 0
  if (offset+=1) =&gt; SECTORS
    offset:=0 
  

&apos;&apos; actually perform spawning
repeat i from wall_spawnpos to wall_spawnpos+size-1
  tmp := byte[wptr++]
  if ccw
    tmp &gt;&lt;= SECTORS
  wallbitmap[i] := (tmp&lt;&lt;offset + tmp&gt;&gt;(SECTORS-offset))&amp;constant((|&lt;SECTORS)-1)

wall_spawnpos += byte[wptr] &apos; spacing

{pst.str(string(&quot;spacing: &quot;))
pst.dec(byte[wptr])
pst.newline }
next_pattern~
 
PRI select_pattern(pattern_list) : pat | i,weight

&apos;&apos; sum total weight
i~
weight~
repeat while pat:=long[pattern_list][i++]
  weight+= (pat&gt;&gt;PATTERN_WEIGHT_SHIFT)&amp;PATTERN_WEIGHT_MASK

weight := (random?&amp;posx) // weight

i~
repeat
  pat:=long[pattern_list][i++]
  if (weight -= (pat&gt;&gt;PATTERN_WEIGHT_SHIFT)&amp;PATTERN_WEIGHT_MASK)&lt;0
    quit

CON

HUECALC_LEFTSAR = 16+3-4
HUECALC_RIGHTSAR = HUECALC_LEFTSAR - 8 -1

PRI huecalc(angl,swing,center) | tmp
tmp := sin(angl)
tmp += tmp~&gt;14
&apos;result := ((tmp~+constant(14-4))&amp;$F0) + (((tmp+$10000)~&gt;constant(14-(4+8)))&amp;$F000)
result := ((((tmp+$0000)*swing)~&gt;HUECALC_LEFTSAR) &amp; $F0) + ((((((tmp+$0000)*swing)~&gt;HUECALC_RIGHTSAR)+$800)~&gt;1) &amp; $F000)
result += center
result &amp;= $F0F0

PRI update | i,j,tmp,tmp2,snes,sectorchange_flag,oldsector,clip_angle,huetmp,lkey,rkey,snes_trigger

&apos;pst.str(string(&quot;update!&quot;,13))

if plat#SNES_PLAYER1 =&gt;0
  snes := SNES_Read_Gamepad
else
  snes~
snes_trigger:=snes&amp;!snes_prev

lkey := kb.keystate($C0) OR snes&amp;constant(SNES_LEFT|SNES_L)
rkey := kb.keystate($C1) OR snes&amp;constant(SNES_RIGHT|SNES_R)

random? &apos; RNG dummy tick

{ &apos;&apos; Old code - ressurect this if you want to add pentagon/square playfield
sector_angles[0]:=0 &apos; first sector is always zero to make life easier
repeat i from 1 to constant(SECTORS-1)
  sector_angles[i] := i*constant(8192/SECTORS)
}

center_x := constant(128&lt;&lt;16)
center_y := constant(119&lt;&lt;16)
view_scale_y:= constant( negx &gt;&gt; ((PRESCALE_SHL-1)) )

{
pst.str(string(&quot;Time: &quot;)) 
pst.dec(game_timer/60)
pst.char(&quot;:&quot;)  
pst.dec(game_timer//60)
pst.newline}

time2dualstr(game_timer,@strbuf_frames) 
              
case state
  PLAY:
    
    if state_timer == 1 &apos; safe to update strbuf_hi
      update_strbuf_hi
      sdda.play_sfx(sdda#SFX_BEGIN)
     
    if state_timer&lt;15
      view_scale_y:=(view_scale_y ** (((15+1)-game_timer)*trunc(float(posx)/10.0*5.0/128.0))) &lt;&lt; 8
    else
      view_scale_y+=byte[subcodeptr]&lt;&lt;17

    ifnot game_timer
      player_angle:=constant((8192/(SECTORS*2))/3)

    &apos;&apos; stage script interpreter
    &apos;&apos; see explanation further down
    repeat
      case tmp2:=word[script_pc]
        $0000..$1FFF: &apos;&apos; SCRIPT_SPIN
          speed_target := (tmp2&lt;&lt;19)~&gt;19
        $2000..$3FFF: &apos;&apos; SCRIPT_POS
          playfield_rotation := tmp2&amp;8191
        $4000..$FFEF: &apos;&apos; SCRIPT_WAIT
          if script_timer &lt; tmp2-$4000
            quit
        $FFF0..$FFFF: &apos;&apos; special commands
          tmp := word[script_pc+=2]
          case tmp2&amp;$F
            $0: &apos;&apos; SCRIPT_CMD_JMP
              script_pc:=@@tmp-2
              script_timer~
            $1: &apos;&apos; SCRIPT_CMD_EFFSTAGE
              effectivestage := tmp
            $2: &apos;&apos; SCRIPT_CMD_PATTERNS
              patternlist := @@tmp
            $3: &apos;&apos; SCRIPT_CMD_WALLSPEED
              wall_speed := tmp
            $4: &apos;&apos; SCRIPT_CMD_PLAYERSPEED
              player_speed := tmp
            $5: &apos;&apos; SCRIPT_CMD_MUSIC
              &apos;&apos; TODO: evaluate firstplay_flag
              if tmp &lt;&gt; current_music
                sdda.play_music(current_music:=tmp)
      script_pc+=2
    script_timer++
     
    &apos;&apos; find player&apos;s sector
    player_sector~
    repeat i from 0 to constant(SECTORS-1)
       if sector_angles[i] =&lt; player_angle
          player_sector := i
     
    &apos;&apos; move player
    if lkey
      player_angle -= player_speed
    if rkey
      player_angle += player_speed
    player_angle&amp;=8191
     
    {
    pst.str(string(&quot;before: &quot;))
    pst.dec(player_sector)
    pst.newline
    }
    &apos;&apos; check for sector change
    sectorchange_flag~                            
    oldsector := player_sector
    if player_sector == 0 AND player_angle =&gt; sector_angles[constant(SECTORS-1)] &apos; special case
        player_sector := constant(SECTORS-1)
        clip_angle := 0
        sectorchange_flag~~
    elseif player_sector == constant(SECTORS-1) AND player_angle &lt; sector_angles[1] &apos; special case
      player_sector := 0
      clip_angle := 8191
      sectorchange_flag~~
    elseif player_sector &lt;&gt; 0 AND player_angle &lt; sector_angles[player_sector]
      clip_angle:=sector_angles[player_sector]
      player_sector--
      sectorchange_flag~~
    elseif player_sector &lt;&gt; constant(SECTORS-1) AND player_angle =&gt; sector_angles[player_sector+1]
      player_sector++
      clip_angle := sector_angles[player_sector]-1
      sectorchange_flag~~ 
    {
    pst.str(string(&quot;after: &quot;))
    pst.dec(player_sector)
    pst.newline
     
    pst.str(string(&quot;flag: &quot;))
    pst.dec(sectorchange_flag)
    pst.newline
    }
    &apos;&apos; check for walls in new sector (to clip when moving sideways into a wall)
    if sectorchange_flag
      if wallbitmap[1] &amp; |&lt;player_sector
        player_sector := oldsector
        player_angle := clip_angle
     
      
     
     
     
     
    &apos;&apos; Move walls closer and kill player
    wall_phase -= wall_speed
    if wall_phase &lt; 0
      tmp:= ((-wall_phase)&gt;&gt;16) &lt;# constant(WALLBUFFER_SIZE-1)
      bytemove(@wallbitmap,@wallbitmap+tmp,WALLBUFFER_SIZE-tmp)
      bytefill(@wallbitmap+WALLBUFFER_SIZE-tmp,0,tmp)
      wall_phase += tmp&lt;&lt;16
      wall_spawnpos -= tmp
      if CHEATZ &lt; 2
        hitflag OR= wallbitmap[1] &amp; |&lt;player_sector

    {
    pst.str(string(&quot;phase: &quot;))
    pst.hex(wall_phase,8)
    pst.newline
    pst.str(string(&quot;next: &quot;))
    pst.hex(next_pattern,8)
    pst.str(string(&quot;list: &quot;))
    pst.hex(patternlist,4)
    pst.newline
    }
    
    &apos;patternlist := @whirlpool2_only&apos;&apos;DEBUG!
     
    &apos;&apos; select next pattern
    if (NOT next_pattern) AND patternlist
      next_pattern := @@0+select_pattern(patternlist)        
     
    &apos;&apos; try spawning next pattern
    if next_pattern
      try_spawn_pattern 

    &apos;&apos; Handle timer-related SFX
    if game_timer==stage_records[stage]+1 and game_timer&lt;&gt;1
      sdda.play_sfx(sdda#SFX_EXCELLENT)
    elseif tmp := time2level(game_timer)
      if leveltimetbl.word[tmp] == game_timer
        sdda.play_sfx(constant(sdda#SFX_LINE-1)+tmp)
    
    game_timer++
  GAMEOVER:
    ifnot state_timer
      time2dualstr(stage_records[stage],@strbuf2_frames) &apos; write best time string
      sdda.play_music(current_music:=-1)
      sdda.play_sfx(sdda#SFX_GAMEOVER)
    if state_timer =&gt; 60
      view_scale_y:=(view_scale_y ** (((state_timer&lt;#constant(60+10))-56)*trunc(float(posx)/10.0*3.0/128.0))) &lt;&lt; 8
      if state_timer &lt; constant(60+10)
        wall_phase+=$8000
        speed_target:= -GAMEOVER_SPIN
    if state_timer == 69 &apos;nice
      try_commit_record
  LEVELSELECT:
    firstplay_flag~~
    center_y := constant(188&lt;&lt;16)
    player_angle := -playfield_rotation+4096
    view_scale_y&lt;&lt;=1
    tmp:=constant(-8192/SECTORS)*stage + constant(8192/(SECTORS*2)*3)
    ifnot state_timer
      playfield_rotation:=tmp
    speed_target:=((tmp-playfield_rotation)&lt;&lt;19)~&gt;19
    if ||speed_target &lt; 64
      if lkey
        if stage-- == 0 &apos; Do this because stage is a byte
          stage:=HYPER_HEXAGONEST
      if rkey
        if ++stage &gt; HYPER_HEXAGONEST
          stage:=0
      if lkey or rkey
        sdda.play_sfx(sdda#SFX_CHOOSE)
    if ||speed_target &lt; 11
      speed_target:=playfield_speed:=0
      playfield_rotation:=tmp
    elseif speed_target &lt; 0 
      speed_target:=-71
    else
      speed_target:=71
    tmp := stage2effstage_tbl.byte[stage]
    if is_current_locked
      tmp := EFF_TITLE
    effectivestage:=tmp
  TITLE:
    center_y := constant(238&lt;&lt;16)
    view_scale_y&lt;&lt;=2
    player_angle := -playfield_rotation &apos; moves player out of frame
    speed_target := -20 &apos;&apos; TODO
    effectivestage := EFF_TITLE
    if state_timer==60
      sdda.play_sfx(sdda#SFX_TITLE)
    

&apos;&apos; select colors
&apos;effectivestage := EFF_HEXAGONER3 &apos;&apos;DEBUG!

tmp:=@effstage_color_tbl+effectivestage&lt;&lt;3 &apos; calc table base address
huetmp := word[tmp][3] &apos; get huecalc_center
if huetmp&amp;$0100 &apos; colorswap flag? 
  if ++colorswap_timer =&gt; 45 &apos; measured
    colorswap_timer~
    NOT playfield_colorswap
else
  playfield_colorswap:=colorswap_timer:=0 

if tmp2:=(huetmp&amp;$F)
  huetmp:= huecalc(framecount*huecalc_tbl.byte[tmp2&lt;&lt;1],huecalc_tbl.byte[tmp2&lt;&lt;1+1],huetmp&amp;$F0F0)
else
  huetmp:= (framecount&amp;$F0)+((framecount+$8)&amp;$F0)&lt;&lt;8 &apos;&apos; Taste the rainbow

color1:=word[tmp][0]+huetmp
color2:=word[tmp][1]+huetmp
if NOT safe_colors AND effectivestage==EFF_HEXAGONER2
  color3:=$8888^huetmp
else
  color3:=word[tmp][2]+huetmp
    
&apos;pst.hex(huetmp,8)
    &apos;pst.newline



if speed_target==SPINSPEED_BW_SPECIAL &apos; special case
  playfield_speed := (((constant(-1*8192/2/SECTORS)-playfield_rotation)&amp;8191)+31)&gt;&gt;5
else &apos;smooth out speed 
  tmp:=speed_target-playfield_speed
  if tmp&lt;0
    playfield_speed += (tmp-constant(SPEED_SMOOTHING-1))/SPEED_SMOOTHING
  elseif tmp&gt;0
    playfield_speed += (tmp+constant(SPEED_SMOOTHING-1))/SPEED_SMOOTHING
   
playfield_rotation += playfield_speed

state_timer++
      
   
repeat while kb.gotkey OR snes_trigger
  if snes_trigger
    tmp~
    case i:=(|&lt;((&gt;|snes_trigger)-1))
      SNES_A: tmp:=&quot; &quot;
      SNES_X: tmp:=&quot;n&quot;
      SNES_Y: tmp:=&quot;b&quot;
      SNES_SELECT: tmp:=$DC
      SNES_START: tmp:= $CB    
    
    snes_trigger &amp;= !i     
  else
    tmp := kb.key
  pst.dec(tmp)
  pst.newline  
  case tmp
    $CB: &apos; Esc
      if state==PLAY
        hitflag~~
      elseif state==GAMEOVER
        try_commit_record
        clearwalls
        state_timer~
        state:=LEVELSELECT
        sdda.play_sfx(sdda#SFX_BACK)
      elseif state==LEVELSELECT
        state_timer~
        state:=TITLE         
        sdda.play_sfx(sdda#SFX_BACK)
    &quot;t&quot;:
      if CHEATZ
        game_timer+= 60
        script_timer += 60
    &quot; &quot;: &apos; Space
      if state==TITLE
        state_timer~
        state:=LEVELSELECT
        sdda.play_sfx(sdda#SFX_SELECT)
      elseif (state==GAMEOVER AND state_timer =&gt; 60) OR (state==LEVELSELECT and NOT is_current_locked)
        try_commit_record
        if stage == HEXAGON AND NOT is_locked(BLACKWHITE) AND lkey AND rkey
          stage:=BLACKWHITE
        clearwalls
        game_timer~
        state_timer~
        script_timer~
        script_pc := @@script_init_tbl.word[stage]
        next_pattern~
        state:=PLAY
    $DC: &apos; printscreen
      gfx.toggle_mode
    $6C9: &apos;Ctrl-Alt-Del : Quit gracefully!
      if state == GAMEOVER
        try_commit_record
      reboot
    other: &apos;ignore
   
if hitflag~
  state := GAMEOVER
  state_timer~
  commit_record_flag~~
  gameover_newrecord_flag:= stage_records[stage] &lt; game_timer 

  
snes_prev:=snes

PRI is_current_locked
return is_locked(stage)

PRI is_locked(which)
ifnot CHEATZ
  case which              
    HYPER_HEXAGON..HYPER_HEXAGONEST:result:= stage_records[which-3] &lt; constant(60*60)
    BLACKWHITE: result:= stage_records[HYPER_HEXAGONEST] &lt; constant(60*60)

DAT
org
effstage_color_tbl word
&apos;&apos;   color1 color2 color3 huecalc_center+colorswap flag
word $0303, $0404, $0505, $0000 &apos; EFF_TITLE
word $0A0A, $0B0B, $0D0D, $9091 &apos; EFF_HEXAGON1
word $0A0A, $0B0B, $0D0D, $1021 &apos; EFF_HEXAGON2
word $0A0A, $0B0B, $0D0D, $C0D1 &apos; EFF_HEXAGON3
word $0202, $0B0B, $0E0E, $5162 &apos; EFF_HEXAGONER1
word $0707, $0E0E, $0C0C, $D1D2 &apos; EFF_HEXAGONER2 (see special case color3 for NOT safe_colors)
word $0B0B, $0D0D, $0707, $D1D2 &apos; EFF_HEXAGONER3
word $0B0B, $0C0C, $0E0E, $0100 &apos; EFF_HEXAGONEST1
word $0404, $0505, $0707, $0100 &apos; EFF_HEXAGONEST2
word $0202, $0202, $0707, $0000 &apos; EFF_BLACKWHITE

huecalc_tbl byte &apos;&apos; indexed by bottom bits of huecalc_center
&apos;&apos;   speed,range
byte  0, 0
byte 35,10
byte 20,20


PRI try_commit_record

if commit_record_flag~
  stage_records[stage] #&gt;= game_timer
  ifnot CHEATZ
    sdda.writesavedata(@save_space)


PRI draw

if state_timer &lt; 5 &apos; Flash?
  gl.triangle(constant((gfx#WIDTH/2)&lt;&lt;16),constant(-gfx#HEIGHT&lt;&lt;16),constant(-gfx#WIDTH&lt;&lt;16),constant(gfx#HEIGHT&lt;&lt;16),constant(2*gfx#WIDTH&lt;&lt;16),constant(gfx#HEIGHT&lt;&lt;16),$0707)
else
  draw_game
  if state == PLAY OR (state == GAMEOVER AND state_timer &lt; 60) 
    draw_hud
  elseif state == GAMEOVER AND state_timer=&gt;70
    draw_gameover
  elseif state == LEVELSELECT
    draw_levelselect
  elseif state == TITLE
    draw_title
return 0 &apos; dont trigger ABORT handler

PRI draw_game : view_scale_x |i,i2,j,tmp,rad,ibuf,wallactive,adjflag,tmp2,rscl1x,rscl1y,rscl2x,rscl2y&apos;,polybuf[SECTORS*2]

view_scale_x := (view_scale_y ** PIXEL_ASPECT_FIX)&lt;&lt;1
&apos;&apos; update/draw playfield
repeat i from 0 to constant(SECTORS-1)
  tmp:=  sector_angles[i]+playfield_rotation
  sector_vx[i] := ((-sin(tmp))&lt;&lt;PRESCALE_SHL)**view_scale_x
  sector_vy[i] := (sin(tmp+2048)&lt;&lt;PRESCALE_SHL)**view_scale_y
 
&apos;&apos; background
repeat i from 0 to constant(SECTORS-1)
  if 0&apos;i==player_sector
    tmp2:=$7D7D
  elseif (playfield_colorswap^i)&amp;1
    tmp2 := color1
  else
    tmp2 := color2
  if (i2 := i+1) =&gt; SECTORS
    i2 -= SECTORS    
  gl.triangle(center_x,center_y,{
  }center_x+sector_vx[i]*PLAYFIELD_RADIUS,center_y+sector_vy[i]*PLAYFIELD_RADIUS,{
  }center_x+sector_vx[i2]*PLAYFIELD_RADIUS,center_y+sector_vy[i2]*PLAYFIELD_RADIUS,tmp2)
 
 
&apos;&apos; central hexagon                   
repeat i from 0 to constant(SECTORS-1)
  polybuf[i&lt;&lt;1] := center_x + sector_vx[i]*HEXAGON1_RADIUS_UNSCALED
  polybuf[i&lt;&lt;1+1] := center_y + sector_vy[i]*HEXAGON1_RADIUS_UNSCALED
gl.polygon(@polybuf,SECTORS,color1)
gl.line_polygon(@polybuf,SECTORS,color3)
 
&apos;&apos; walls
wallactive~
repeat j from WALLDRAW_MAX to -1
  tmp2:=wallbitmap[j]
  if (tmp := ((j)&lt;&lt;16)+wall_phase+PLAYER_RADIUS_WALLSPACE) &lt; -$0_0000
    tmp2~
  ifnot (tmp2)^wallactive
    next
  rad:=HEXAGON1_RADIUS_UNSCALED + (tmp*WALL_UNIT_UNSCALED) ~&gt;constant(16)
  adjflag~
  repeat i from 0 to constant(SECTORS-1)
    if (i2 := i+1) =&gt; SECTORS
        i2 -= SECTORS
    ibuf := @polybuf+i&lt;&lt;5      
    if tmp2 &amp; |&lt;i AND NOT (wallactive &amp; |&lt;i) &apos; wall starts, generate outer vertices
      
      &apos; outer 1
      if adjflag
        longmove(ibuf,adjflag,2)
      else
        long[ibuf][0] := center_x + sector_vx[i]*rad
        long[ibuf][1] := center_y + sector_vy[i]*rad
       
      &apos; outer 2
      long[ibuf][2] := center_x + sector_vx[i2]*rad
      long[ibuf][3] := center_y + sector_vy[i2]*rad
      adjflag:=ibuf+constant(2*4)
    elseif !tmp2 &amp; |&lt;i AND (wallactive &amp; |&lt;i) &apos;wall ends, generate inner vertices and submit
      &apos; inner vertices&apos; X
      if adjflag
        longmove(ibuf+constant(6*4),adjflag,2)
      else
        long[ibuf][6] := center_x + sector_vx[i]* (rad#&gt;HEXAGON1_RADIUS_UNSCALED)
      long[ibuf][4] := center_x + sector_vx[i2]*(rad#&gt;HEXAGON1_RADIUS_UNSCALED)
       
      if (long[ibuf][6]#&gt;long[ibuf][4]) &lt; 0
        &apos;pst.str(string(&quot;skip 1&quot;,13))
        adjflag~
        next &apos; perform X clipping because the GL doesn&apos;t, lol
      if (long[ibuf][6]&lt;#long[ibuf][4]) =&gt; constant(gfx#WIDTH&lt;&lt;16)
        &apos;pst.str(string(&quot;skip 2&quot;,13))
        adjflag~
        next &apos; perform X clipping because the GL doesn&apos;t, lol
      &apos; inner vertices&apos; Y
      ifnot adjflag                                 
        long[ibuf][7] := center_y + sector_vy[i]* (rad#&gt;HEXAGON1_RADIUS_UNSCALED)
      long[ibuf][5] := center_y + sector_vy[i2]*(rad#&gt;HEXAGON1_RADIUS_UNSCALED)
      {pst.str(string(&quot;submitting poly... &quot;))
      pst.dec(j)
      pst.char(&quot; &quot;)
      pst.dec(i)
      pst.char(&quot; &quot;)
      pst.dec(ibuf - @polybuf)
      pst.newline}         
      gl.polygon(ibuf,4,color3)
      adjflag:= ibuf+constant(4*4)
    else
      adjflag~
  wallactive:=tmp2

 
&apos;&apos;player
tmp :=  (-sin(player_angle+playfield_rotation) &lt;&lt; PRESCALE_SHL)**view_scale_x
tmp2 := (sin(player_angle+playfield_rotation+2048) &lt;&lt; PRESCALE_SHL)**view_scale_y        
rscl1x := tmp*constant(PLAYER_RADIUS_UNSCALED-4)
rscl1y := tmp2*constant(PLAYER_RADIUS_UNSCALED-4)
rscl2x := tmp2*3
rscl2y := tmp*3                                             
gl.triangle(center_x + (tmp*PLAYER_RADIUS_UNSCALED),center_y + (tmp2*PLAYER_RADIUS_UNSCALED),{
           }center_x + rscl1x + rscl2x ,{            
           }center_y + rscl1y - rscl2y ,{
           }center_x + rscl1x - rscl2x ,{            
           }center_y + rscl1y + rscl2y ,color3)

PRI draw_hud : lev | tmp,tmp2,ttx,barleft,barright,blink 
&apos;&apos; HUD
if game_timer=&gt;constant(100*60)
  tmp:=constant(4*8)
  ttx:=constant(142-18)
else
  tmp:=0
  ttx:=142
gl.polygon(@hud_topright_poly1+tmp,4,$0202)
gl.polygon(@hud_topright_poly2+tmp,4,$0202)
gl.polygon(@hud_topleft_poly,4,$0202)
 
gl.text_inline(224,constant(4+8),0,0,@strbuf_frames,fontptr,$0707)                                 
gl.text_inline(174,4,1,1,@strbuf_secs,fontptr,$0707)

tmp := string(&quot; TIME&quot;) 
if stage =&gt; HYPER_HEXAGON
  tmp := @hyper_str

gl.text(ttx,4,0,0,tmp,fontptr,$0707) 

blink~

if (barright:=stage_records[stage]) =&gt; {1&apos;}constant(60*60)
  barleft:=0
  tmp:=@strbuf_hi
  if (blink:=barright - game_timer) &lt; 0
    tmp:=@record_str
                              
else 
  lev := time2level(game_timer)
  barleft:=leveltimetbl.word[lev]
  barright:=leveltimetbl.word[lev+1]
  if lev
    blink:=barleft-game_timer
  else
    blink:=1
  tmp:=@@levelstringtbl.word[lev]
&apos;gl.text(10,4,0,0,tmp,fontptr,$0707)
if state_timer&amp;8 AND (blink &gt; -45 AND blink =&lt; 0)
  tmp2:=$0505
else
  tmp2:=$0707
gl.text_centered(46,4,0,0,tmp,fontptr,tmp2)
  
  

if barright
  tmp := constant(10&lt;&lt;16)+(((game_timer-barleft)&lt;&lt;16)/(barright-barleft) &lt;# $1_0000)*71
  gl.line(constant(10&lt;&lt;16),constant(14&lt;&lt;16),tmp,constant(14&lt;&lt;16),color3)
  gl.line(tmp,constant(14&lt;&lt;16),constant(81&lt;&lt;16),constant(14&lt;&lt;16),color2) 
else        
  gl.line(constant(10&lt;&lt;16),constant(14&lt;&lt;16),constant(81&lt;&lt;16),constant(14&lt;&lt;16),color3)

DAT
org
hud_topright_poly1
long 133&lt;&lt;16, -1&lt;&lt;16
long 260&lt;&lt;16, -1&lt;&lt;16 
long 260&lt;&lt;16, 15&lt;&lt;16
long 141&lt;&lt;16, 15&lt;&lt;16
hud_topright_poly1_big
long 115&lt;&lt;16, -1&lt;&lt;16
long 260&lt;&lt;16, -1&lt;&lt;16 
long 260&lt;&lt;16, 15&lt;&lt;16
long 123&lt;&lt;16, 15&lt;&lt;16

hud_topright_poly2
long 185&lt;&lt;16, 15&lt;&lt;16
long 260&lt;&lt;16, 15&lt;&lt;16  
long 260&lt;&lt;16, 23&lt;&lt;16
long 189&lt;&lt;16, 23&lt;&lt;16
hud_topright_poly2_big
long 167&lt;&lt;16, 15&lt;&lt;16
long 260&lt;&lt;16, 15&lt;&lt;16  
long 260&lt;&lt;16, 23&lt;&lt;16
long 171&lt;&lt;16, 23&lt;&lt;16
       
hud_topleft_poly
long  96&lt;&lt;16, -5&lt;&lt;16
long  -4&lt;&lt;16, -5&lt;&lt;16   
long  -4&lt;&lt;16, 15&lt;&lt;16
long  86&lt;&lt;16, 15&lt;&lt;16

PRI draw_gameover | lev,i,delta,angl,tmp,tmp2,fonttmp
fonttmp:=fontptr
gl.polygon(@gameover_last_poly1,4,$0202)
gl.polygon(@gameover_last_poly2,4,$0202)         
gl.text(116, 75,0,0,string(&quot;LAST&quot;),fonttmp,$0707)

gl.text_inline(224,constant(76+8),0,0,@strbuf_frames,fonttmp,$0707)                                 
gl.text_inline(172,76,1,1,@strbuf_secs,fonttmp,$0707)  
gl.polygon(@gameover_best_poly1,4,$0202)  
if gameover_newrecord_flag
  gl.text(138,125,0,0,@new_record_str,fonttmp,$0707)
else
  gl.polygon(@gameover_best_poly2,4,$0202)
  gl.text(129,125,0,0,string(&quot;BEST&quot;),fonttmp,$0707)
  gl.text(224,constant(126+8),0,0,@strbuf2_frames,fonttmp,$0707)                                 
  gl.text(172,126,1,1,@strbuf2_secs,fonttmp,$0707)

gl.polygon(@gameover_big_poly,4,$0202)      
lev := time2level(stage_records[stage])
tmp:=string(&quot;LEVEL N&quot;)
byte[tmp][6] := &quot;1&quot;+lev
gl.text_inline( 13, 75,0,0,tmp,fonttmp,$0707)
gl.text_ljust( 85, 84,0,0,@@levelstringtbl.word[lev],fonttmp,$0707)

&apos;&apos; draw regular polygon, lol

if lev &lt;&gt; 0
  tmp:=lev
  tmp2:=GAMEOVER_POLY_RADIUS
  angl:=playfield_rotation
else
  tmp:=3
  tmp2:=1
  angl:=0
delta:=8192/(tmp+1)
repeat i from 0 to tmp
  polybuf[i&lt;&lt;1]   := GAMEOVER_POLY_X+((-sin(angl)*tmp2)&lt;&lt;1)**PIXEL_ASPECT_FIX
  polybuf[i&lt;&lt;1+1] := GAMEOVER_POLY_Y+(sin(angl+2048)*tmp2)
  angl+=delta
     
gl.line_polygon(@polybuf,tmp+1,color3) 

CON

GAMEOVER_POLY_X = 54&lt;&lt;16
GAMEOVER_POLY_Y = 118&lt;&lt;16
GAMEOVER_POLY_RADIUS = 24

DAT
org
gameover_best_poly1 long
long 121&lt;&lt;16,121&lt;&lt;16
long 260&lt;&lt;16,121&lt;&lt;16 
long 260&lt;&lt;16,137&lt;&lt;16
long 129&lt;&lt;16,137&lt;&lt;16

gameover_best_poly2 long
long 167&lt;&lt;16,137&lt;&lt;16
long 260&lt;&lt;16,137&lt;&lt;16  
long 260&lt;&lt;16,145&lt;&lt;16
long 171&lt;&lt;16,145&lt;&lt;16

gameover_last_poly1 long
long 106&lt;&lt;16, 71&lt;&lt;16
long 260&lt;&lt;16, 71&lt;&lt;16 
long 260&lt;&lt;16, 87&lt;&lt;16
long 114&lt;&lt;16, 87&lt;&lt;16

gameover_last_poly2 long
long 167&lt;&lt;16, 87&lt;&lt;16
long 260&lt;&lt;16, 87&lt;&lt;16  
long 260&lt;&lt;16, 95&lt;&lt;16
long 171&lt;&lt;16, 95&lt;&lt;16

gameover_big_poly long
long  82&lt;&lt;16, 71&lt;&lt;16
long  -4&lt;&lt;16, 71&lt;&lt;16
long  -4&lt;&lt;16,145&lt;&lt;16
long 119&lt;&lt;16,145&lt;&lt;16

PRI draw_levelselect | fonttmp,stn,locked
fonttmp:=fontptr
if locked:=is_current_locked
  stn := string(&quot;LOCKED&quot;)  
else
  stn := @@stagestringtbl.word[stage]
gl.polygon(@levelselect_poly,4,$0202)
gl.text_centered(128,42,1,1,stn,fonttmp,color3)
ifnot locked
  if stage =&gt; HYPER_HEXAGON
    gl.polygon(@levelselect_poly_hyper,4,$0202)
    gl.text(200,31,0,0,@hyper_str,fonttmp,color3)
   
  gl.text(10,60,0,0,string(&quot;DIFFICULTY:&quot;),fonttmp,$0505)
  gl.text(constant(10+12*9),60,0,0,@@stagedifficultytbl.word[stage],fonttmp,$0707)
  update_strbuf_hi
  gl.text(10,69,0,0,string(&quot;BEST TIME:&quot;),fonttmp,$0505)
  gl.text_inline(constant(10+12*9),69,0,0,@strbuf_hi,fonttmp,$0707)
   
DAT
org
levelselect_poly long
long  -4&lt;&lt;16, 37&lt;&lt;16
long 260&lt;&lt;16, 37&lt;&lt;16 
long 260&lt;&lt;16,101&lt;&lt;16
long  -4&lt;&lt;16,101&lt;&lt;16

levelselect_poly_hyper long
long 186&lt;&lt;16, 29&lt;&lt;16
long 260&lt;&lt;16, 29&lt;&lt;16 
long 260&lt;&lt;16, 37&lt;&lt;16
long 190&lt;&lt;16, 37&lt;&lt;16

CON
LOGO_X = 52
LOGO_Y = 64
PRI draw_title | fonttmp
fonttmp:=fontptr
gl.text(LOGO_X,LOGO_Y,2,2,string(&quot;SPIN&quot;),fonttmp,$0707)
gl.text(constant(LOGO_X+28),constant(LOGO_Y+34),1,1,string(&quot;HEXAGON&quot;),fonttmp,$0707)
gl.text(12,216,0,0,string(&quot;V1.0 RC4&quot;),fonttmp,$0707) 

PUB sin(angle) : s | c,z
              &apos;angle: 0..8192 = 360&deg;
  s := angle
  if angle &amp; $800
    s := -s
  s |= $E000&gt;&gt;1
  s &lt;&lt;= 1
  s := word[s]
  if angle &amp; $1000
    s := -s                    &apos; return sin = -$FFFF..+$FFFF 

PRI update_strbuf_hi | tmp,tmp2,spaces
spaces:=2
tmp2:=stage_records[stage]
tmp := tmp2//60
tmp2:= tmp2/60
strbuf_hi[4] := &quot;:&quot;
strbuf_hi[5] := &quot;0&quot;+tmp/10
strbuf_hi[6] := &quot;0&quot;+tmp//10
if tmp2 =&gt; 100 &apos; WTF?
  spaces:=1
  if tmp2 =&gt; 1000
    spaces:=0
    strbuf_hi[0] := &quot;0&quot;+tmp2/1000
    tmp2//=1000 
  strbuf_hi[1] := &quot;0&quot;+tmp2/100
  tmp2//=100 
strbuf_hi[2] := &quot;0&quot;+tmp2/10
strbuf_hi[3] := &quot;0&quot;+tmp2//10
strbuf_hi[7] := 0
bytemove(@strbuf_hi,@strbuf_hi+spaces,8-spaces)

PRI time2dualstr(time,bufptr) | frames,seconds
seconds:= time/60
frames := time//60
byte[bufptr][0] := &quot;:&quot;
byte[bufptr][1] := &quot;0&quot;+frames/10
byte[bufptr][2] := &quot;0&quot;+frames//10
byte[bufptr][3] := 0
 
if seconds &gt; 99 
  byte[bufptr][4] := &quot;0&quot;+((seconds/100)&lt;#9)
  seconds//=100
else
  byte[bufptr][4] := &quot; &quot;
byte[bufptr][5] := &quot;0&quot;+seconds/10
byte[bufptr][6] := &quot;0&quot;+seconds//10 
byte[bufptr][7] := 0 

PRI time2level(frames) | tmp
tmp:=frames
if (tmp-=constant(10*60)) &lt; 0
  return 0   
elseif (tmp-=constant(10*60)) &lt; 0
  return 1       
elseif (tmp-=constant(10*60)) &lt; 0
  return 2      
elseif (tmp-=constant(15*60)) &lt; 0
  return 3        
elseif (tmp-=constant(15*60)) &lt; 0
  return 4
else
  return 5     


DAT
org

point_str    byte &quot;POINT&quot;,0
line_str     byte &quot;LINE&quot;,0
triangle_str byte &quot;TRIANGLE&quot;,0
square_str   byte &quot;SQUARE&quot;,0
pentagon_str byte &quot;PENTAGON&quot;,0
blackwhite_str byte &quot;FINAL &quot;
hexagon_str  byte &quot;HEXAGON&quot;,0
hexagoner_str  byte &quot;HEXAGONER&quot;,0
hexagonest_str  byte &quot;HEXAGONEST&quot;,0

hard_str byte &quot;HARD&quot;,0
harder_str byte &quot;HARDER&quot;,0
hardest_str byte &quot;HARDEST&quot;,0
hardester_str byte &quot;HARDESTER&quot;,0
hardestest_str byte &quot;HARDESTEST&quot;,0
hardestestest_str byte &quot;HARDESTESTEST&quot;,0

CON
{{
Script format:
word $XXXX where X is $0000..$1FFF : set spin speed to X (sign-extended)
word $XXXX where X is $2000..$3FFF : set spin position to X&amp;8191
word $XXXX where X is $4000..$FFEF : wait until script_timer =&gt; (X-$4000)
word $FFFX : special command X

special command 0: clear script_timer and jump to X
word @X

special command 1: set effectivestage X
word X

special command 2: set pattern list X
word @X

special command 3: set wall speed
word X

special command 4: set player speed
word X

special command 5: set music
word sdda#MUSIC_X

}}
SCRIPT_SPIN = $0000
SCRIPT_SPINMASK = $1FFF
SCRIPT_POS  = $2000
SCRIPT_POSMASK  = $1FFF &apos; 8191
SCRIPT_WAIT = $4000
SCRIPT_CMD_JMP = $FFF0
SCRIPT_CMD_EFFSTAGE = $FFF1
SCRIPT_CMD_PATTERNS = $FFF2
SCRIPT_CMD_WALLSPEED = $FFF3
SCRIPT_CMD_PLAYERSPEED = $FFF4
SCRIPT_CMD_MUSIC = $FFF5

SPINSPEED_BW_SPECIAL = -4096

PLAYERSPEED_NORMAL = 8192/(SECTORS*8) &apos; measured
PLAYERSPEED_FAST   = 8192/(SECTORS*6) &apos; measured

SECTOR_ANGLE_F = 8192.0 / float(SECTORS)

GAMEOVER_SPIN = round(SECTOR_ANGLE_F/60.0)                     

HEXAGON_SPIN_SLOW = round(SECTOR_ANGLE_F/60.0)
HEXAGON_SPIN = round(SECTOR_ANGLE_F/30.0)

HYPER_HEXAGON_SPIN = round(SECTOR_ANGLE_F/20.0)

HEXAGONER_SPIN_SLOW = round(SECTOR_ANGLE_F/60.0)
HEXAGONER_SPIN = round(SECTOR_ANGLE_F/30.0)

HYPER_HEXAGONER_SPIN = round(SECTOR_ANGLE_F/20.0)

HEXAGONEST_SPIN_SLOW = round(SECTOR_ANGLE_F/30.0)
HEXAGONEST_SPIN = round(SECTOR_ANGLE_F/20.0)
HEXAGONEST_SPIN_FAST = round(SECTOR_ANGLE_F/8.0)

HYPER_HEXAGONEST_SPIN_SLOW = round(SECTOR_ANGLE_F/20.0)
HYPER_HEXAGONEST_SPIN = round(SECTOR_ANGLE_F/15.0)


DAT
org
script_init_tbl word
word @script_hexagon &apos; Hexagon
word @script_hexagoner &apos; Hexagoner
word @script_hexagonest &apos; Hexagonest
word @script_hyper_hexagon &apos; Hyper Hexagon
word @script_hyper_hexagoner &apos; Hyper Hexagoner
word @script_hyper_hexagonest &apos; Hyper Hexagonest
word @script_blackwhite &apos; BW


script_hexagon
word SCRIPT_CMD_EFFSTAGE, EFF_HEXAGON1
word SCRIPT_CMD_MUSIC, sdda#MUSIC_COURTESY
word SCRIPT_CMD_PATTERNS, @hexagon_patterns_simple
word SCRIPT_CMD_WALLSPEED, $1B00 &apos;assumption?
word SCRIPT_CMD_PLAYERSPEED, PLAYERSPEED_NORMAL
word SCRIPT_SPIN+( +HEXAGON_SPIN_SLOW &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*7+30 &apos; Rough
word SCRIPT_SPIN+( -HEXAGON_SPIN_SLOW &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*10 &apos; Exact
word SCRIPT_SPIN+( +HEXAGON_SPIN &amp;SCRIPT_SPINMASK)
word SCRIPT_CMD_PATTERNS, @hexagon_patterns

word SCRIPT_WAIT+60*15+12 &apos; Rough
word SCRIPT_SPIN+( -HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*24+30 &apos; Exact?
word SCRIPT_SPIN+( +HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*33+00 &apos; Exact
word SCRIPT_SPIN+( -HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*41+24 &apos; Rough
word SCRIPT_SPIN+( +HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*48+24 &apos; Rough
word SCRIPT_SPIN+( -HEXAGON_SPIN&amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*53+53 &apos; Rough
word SCRIPT_SPIN+( +HEXAGON_SPIN &amp;SCRIPT_SPINMASK)


word SCRIPT_WAIT+60*60
word SCRIPT_CMD_JMP, @script_hyper_hexagon



script_hyper_hexagon
word SCRIPT_CMD_EFFSTAGE, EFF_HEXAGON2
word SCRIPT_CMD_MUSIC, sdda#MUSIC_COURTESY
word SCRIPT_CMD_PATTERNS, @hyper_hexagon_patterns
word SCRIPT_CMD_WALLSPEED, $2200 &apos;assumption?
word SCRIPT_CMD_PLAYERSPEED, PLAYERSPEED_NORMAL
word SCRIPT_SPIN+( +HYPER_HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*1+35 &apos; Rough
word SCRIPT_SPIN+( -HYPER_HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*9+15 &apos; Rough
word SCRIPT_SPIN+( +HYPER_HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*14+15 &apos; Rough
word SCRIPT_SPIN+( -HYPER_HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*18+05 &apos; Rough
word SCRIPT_SPIN+( +HYPER_HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*22+30 &apos; Rough
word SCRIPT_SPIN+( -HYPER_HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*27+00 &apos; Rough
word SCRIPT_SPIN+( +HYPER_HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*33+30 &apos; Rough
word SCRIPT_SPIN+( -HYPER_HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*39+30 &apos; Rough
word SCRIPT_SPIN+( +HYPER_HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*44+15 &apos; Rough
word SCRIPT_SPIN+( -HYPER_HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*49+55 &apos; Rough
word SCRIPT_SPIN+( +HYPER_HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*57+33 &apos; Rough
word SCRIPT_SPIN+( -HYPER_HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*60
word SCRIPT_CMD_EFFSTAGE, EFF_HEXAGON3

word SCRIPT_WAIT+60*64+07 &apos; Rough
word SCRIPT_SPIN+( +HYPER_HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*68+57 &apos; Rough
word SCRIPT_SPIN+( -HYPER_HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*72+48 &apos; Rough
word SCRIPT_SPIN+( +HYPER_HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*79+20 &apos; Rough
word SCRIPT_SPIN+( -HYPER_HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*85+20 &apos; Rough
word SCRIPT_SPIN+( +HYPER_HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*91+32 &apos; Rough
word SCRIPT_SPIN+( -HYPER_HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*96+16 &apos; Rough
word SCRIPT_SPIN+( -HYPER_HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*101+00 &apos; Rough
word SCRIPT_SPIN+( +HYPER_HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*105+23 &apos; Rough
word SCRIPT_SPIN+( -HYPER_HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*111+44 &apos; Rough
word SCRIPT_SPIN+( +HYPER_HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*117+00 &apos; Rough
word SCRIPT_SPIN+( -HYPER_HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*118+00 &apos; Rough
word SCRIPT_SPIN+( +HYPER_HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*119+00 &apos; Rough
word SCRIPT_SPIN+( -HYPER_HEXAGON_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*120
word SCRIPT_CMD_JMP, @script_hyper_hexagoner



script_hexagoner
word SCRIPT_CMD_EFFSTAGE, EFF_HEXAGONER1   
word SCRIPT_CMD_MUSIC, sdda#MUSIC_OTIS
word SCRIPT_CMD_PATTERNS, @hexagoner_patterns
word SCRIPT_CMD_WALLSPEED, $2000 &apos;assumption?
word SCRIPT_CMD_PLAYERSPEED, PLAYERSPEED_NORMAL
word SCRIPT_SPIN+( +HEXAGONER_SPIN_SLOW &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*9+30 &apos; Rough
word SCRIPT_SPIN+( -HEXAGONER_SPIN_SLOW &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*12+10 &apos; Rough
word SCRIPT_SPIN+( +HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*21+15 &apos; Rough
word SCRIPT_SPIN+( -HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*26+06 &apos; Rough
word SCRIPT_SPIN+( +HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*34+53 &apos; Rough
word SCRIPT_SPIN+( -HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*38+40 &apos; Rough
word SCRIPT_SPIN+( +HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*44+45 &apos; Rough
word SCRIPT_SPIN+( -HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*49+15 &apos; Rough
word SCRIPT_SPIN+( +HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*58+43 &apos; Rough
word SCRIPT_SPIN+( -HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*60
word SCRIPT_CMD_JMP, @script_hyper_hexagoner

script_hyper_hexagoner
word SCRIPT_CMD_EFFSTAGE, EFF_HEXAGONER2      
word SCRIPT_CMD_MUSIC, sdda#MUSIC_OTIS
word SCRIPT_CMD_PATTERNS, @hyper_hexagoner_patterns
word SCRIPT_CMD_WALLSPEED, $2400 &apos;assumption?
word SCRIPT_CMD_PLAYERSPEED, PLAYERSPEED_NORMAL
word SCRIPT_SPIN+( -HYPER_HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*01+36 &apos; Rough
word SCRIPT_SPIN+( +HYPER_HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*04+00 &apos; Manual
word SCRIPT_SPIN+( -HYPER_HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*08+03 &apos; Rough
word SCRIPT_SPIN+( +HYPER_HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*13+20 &apos; Rough
word SCRIPT_SPIN+( -HYPER_HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*18+20 &apos; Rough
word SCRIPT_SPIN+( +HYPER_HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*23+39 &apos; Rough
word SCRIPT_SPIN+( -HYPER_HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*28+53 &apos; Rough
word SCRIPT_SPIN+( +HYPER_HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*35+32 &apos; Rough
word SCRIPT_SPIN+( -HYPER_HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*45+05 &apos; Rough
word SCRIPT_SPIN+( +HYPER_HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*53+00 &apos; Rough
word SCRIPT_SPIN+( -HYPER_HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*60
word SCRIPT_CMD_EFFSTAGE, EFF_HEXAGONER3

word SCRIPT_WAIT+60*62+35 &apos; Rough
word SCRIPT_SPIN+( +HYPER_HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*70+51 &apos; Rough
word SCRIPT_SPIN+( -HYPER_HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*78+55 &apos; Rough
word SCRIPT_SPIN+( +HYPER_HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*83+57 &apos; Rough
word SCRIPT_SPIN+( -HYPER_HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)
                     
word SCRIPT_WAIT+60*91+00 &apos; Rough
word SCRIPT_SPIN+( +HYPER_HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*96+25 &apos; Rough
word SCRIPT_SPIN+( -HYPER_HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*103+16 &apos; Rough
word SCRIPT_SPIN+( +HYPER_HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*109+31 &apos; Rough
word SCRIPT_SPIN+( -HYPER_HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*119+00 &apos; Rough
word SCRIPT_SPIN+( +HYPER_HEXAGONER_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*120
word SCRIPT_CMD_JMP, @script_hyper_hexagonest



script_hexagonest
word SCRIPT_CMD_EFFSTAGE, EFF_HEXAGONEST1      
word SCRIPT_CMD_MUSIC, sdda#MUSIC_FOCUS
word SCRIPT_CMD_PATTERNS, @hexagonest_patterns
word SCRIPT_CMD_WALLSPEED, $2666 &apos;assumption?
word SCRIPT_CMD_PLAYERSPEED, PLAYERSPEED_FAST
word SCRIPT_SPIN+( +HEXAGONEST_SPIN_SLOW &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*05+11 &apos; Rough
word SCRIPT_SPIN+( -HEXAGONEST_SPIN_SLOW &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*06+50 &apos; Rough
word SCRIPT_SPIN+( +HEXAGONEST_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*10+30 &apos; Rough
word SCRIPT_SPIN+( -HEXAGONEST_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*10+45 &apos; Rough
word SCRIPT_SPIN+( -HEXAGONEST_SPIN_FAST &amp;SCRIPT_SPINMASK)
word SCRIPT_WAIT+60*11+15 &apos; Rough
word SCRIPT_SPIN+( 0 &amp;SCRIPT_SPINMASK)
word SCRIPT_WAIT+60*11+25 &apos; Rough
word SCRIPT_SPIN+( -HEXAGONEST_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*15+25 &apos; Rough
word SCRIPT_SPIN+( +HEXAGONEST_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*19+00 &apos; Exact
word SCRIPT_SPIN+( -HEXAGONEST_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*24+00 &apos; Exact
word SCRIPT_SPIN+( +HEXAGONEST_SPIN_FAST &amp;SCRIPT_SPINMASK)
word SCRIPT_WAIT+60*24+40 &apos; Rough
word SCRIPT_SPIN+( 0 &amp;SCRIPT_SPINMASK)
word SCRIPT_WAIT+60*24+50 &apos; Rough
word SCRIPT_SPIN+( +HEXAGONEST_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*29+50 &apos; Rough
word SCRIPT_SPIN+( -HEXAGONEST_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*37+45 &apos; Rough
word SCRIPT_SPIN+( +HEXAGONEST_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*42+53 &apos; Rough
word SCRIPT_SPIN+( -HEXAGONEST_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*46+30 &apos; Exact
word SCRIPT_SPIN+( +HEXAGONEST_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*53+21 &apos; Rough
word SCRIPT_SPIN+( -HEXAGONEST_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*56+00 &apos; Exact
word SCRIPT_SPIN+( -HEXAGONEST_SPIN_FAST &amp;SCRIPT_SPINMASK)
word SCRIPT_WAIT+60*56+40 &apos; Rough
word SCRIPT_SPIN+( 0 &amp;SCRIPT_SPINMASK)
word SCRIPT_WAIT+60*56+50 &apos; Rough
word SCRIPT_SPIN+( +HEXAGONEST_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*60
word SCRIPT_CMD_JMP, @script_hyper_hexagonest



script_hyper_hexagonest
word SCRIPT_CMD_EFFSTAGE, EFF_HEXAGONEST2    
word SCRIPT_CMD_MUSIC, sdda#MUSIC_FOCUS
word SCRIPT_CMD_PATTERNS, @hyper_hexagonest_patterns
word SCRIPT_CMD_WALLSPEED, $2B00 &apos;assumption?
word SCRIPT_CMD_PLAYERSPEED, PLAYERSPEED_FAST
word SCRIPT_SPIN+( +HYPER_HEXAGONEST_SPIN_SLOW &amp;SCRIPT_SPINMASK) &apos;&apos; TODO

word SCRIPT_WAIT+60*04+00 &apos; Manual
word SCRIPT_SPIN+( +HYPER_HEXAGONEST_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*08+20 &apos; Manual
word SCRIPT_SPIN+( -HYPER_HEXAGONEST_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*12+50 &apos; Manual
word SCRIPT_SPIN+( +HYPER_HEXAGONEST_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*17+30 &apos; Manual
word SCRIPT_SPIN+( -HYPER_HEXAGONEST_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*21+40 &apos; Manual
word SCRIPT_SPIN+( +HYPER_HEXAGONEST_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*27+30 &apos; Manual
word SCRIPT_SPIN+( -HYPER_HEXAGONEST_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*34+40 &apos; Manual
word SCRIPT_SPIN+( +HYPER_HEXAGONEST_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*41+30 &apos; Manual
word SCRIPT_SPIN+( -HYPER_HEXAGONEST_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*45+40 &apos; Manual
word SCRIPT_SPIN+( +HYPER_HEXAGONEST_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*50+50 &apos; Manual
word SCRIPT_SPIN+( -HYPER_HEXAGONEST_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*56+20 &apos; Manual
word SCRIPT_SPIN+( +HYPER_HEXAGONEST_SPIN &amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*60
word SCRIPT_CMD_JMP, @script_blackwhite



script_blackwhite
word SCRIPT_CMD_EFFSTAGE, EFF_BLACKWHITE        
word SCRIPT_CMD_MUSIC, sdda#MUSIC_BLACKWHITE
word SCRIPT_CMD_PATTERNS, @blackwhite_patterns
word SCRIPT_CMD_WALLSPEED, $2B00 &apos;assumption?
word SCRIPT_CMD_PLAYERSPEED, PLAYERSPEED_FAST
word SCRIPT_SPIN+(SPINSPEED_BW_SPECIAL&amp;SCRIPT_SPINMASK)

word SCRIPT_WAIT+60*10
word SCRIPT_POS+( -1 &amp; SCRIPT_POSMASK)
word SCRIPT_CMD_JMP, @script_blackwhite
 

script_idle
word SCRIPT_WAIT+1
word SCRIPT_CMD_JMP, @script_idle



DAT
long
          {
long @pattern_solo1     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 10&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_triplec   +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 5&lt;&lt;PATTERN_WEIGHT_SHIFT

long @pattern_solo2     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 8&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo2_opp +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 8&lt;&lt;PATTERN_WEIGHT_SHIFT

long @pattern_solo3     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 7&lt;&lt;PATTERN_WEIGHT_SHIFT 
long @pattern_solo3_dbl +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 6&lt;&lt;PATTERN_WEIGHT_SHIFT
 
long @pattern_solo4     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 8&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo4_dbl +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo4_thk +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT

long @pattern_multic    +PATTERN_CW  + OFFSET_RANDOMIZE2&lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT 
long @pattern_rain      +PATTERN_CW  + 0                &lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT 

long @pattern_whirlpool +PATTERN_CW  + OFFSET_RANDOMIZE2&lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT 
long @pattern_whirlpool2+PATTERN_CW  + OFFSET_RANDOMIZE2&lt;&lt;PATTERN_OFFSET_SHIFT  + 22&lt;&lt;PATTERN_WEIGHT_SHIFT

long @pattern_2spin     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT &apos;}
&apos;long @pattern_3spin    +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT
&apos;long @pattern_4spin    +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT

                                                                                                          {
long @pattern_321       +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_bat       +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_ladder    +PATTERN_CW  + OFFSET_RANDOMIZE2&lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT &apos;}
&apos;long @pattern_stair1   +PATTERN_CW  + OFFSET_RANDOMIZE2&lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT
&apos;long @pattern_stair2   +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT
&apos;}

whirlpool2_only
long @pattern_whirlpool2+PATTERN_CW  + 0&lt;&lt;PATTERN_OFFSET_SHIFT                  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
&apos;long @pattern_2spin +PATTERN_CCW + 0 &lt;&lt;PATTERN_OFFSET_SHIFT                      + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
long 0

hexagon_patterns
long @pattern_whirlpool +PATTERN_CW  + OFFSET_RANDOMIZE2&lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_bat       +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_ladder    +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT

hexagon_patterns_simple 
long @pattern_solo1     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 10&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_triplec   +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 6&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo2     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 8&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo2_opp +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 5&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo3     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 7&lt;&lt;PATTERN_WEIGHT_SHIFT 
long @pattern_solo3_dbl +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 5&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo3_thk +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT 
long @pattern_solo4     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo4_dbl +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo4_thk +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT
long 0 

hyper_hexagon_patterns
long @pattern_solo1     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 10&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_triplec   +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 6&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo2     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 8&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo2_opp +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 8&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo3     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 5&lt;&lt;PATTERN_WEIGHT_SHIFT 
long @pattern_solo3_dbl +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 5&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo3_thk +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo4     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo4_dbl +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo4_thk +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT

long @pattern_whirlpool +PATTERN_CW  + OFFSET_RANDOMIZE2&lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_bat       +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_ladder    +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_stair1   +PATTERN_CW  + OFFSET_RANDOMIZE2&lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_321      +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT
long 0

hexagoner_patterns
long @pattern_solo1     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 9&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_triplec   +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 5&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo2     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 8&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo2_opp +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 5&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo3     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 5&lt;&lt;PATTERN_WEIGHT_SHIFT 
long @pattern_solo3_dbl +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo3_thk +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT 
long @pattern_solo4     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 8&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo4_dbl +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo4_thk +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT

long @pattern_2spin     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_4spin     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_multic    +PATTERN_CW  + OFFSET_RANDOMIZE2&lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT 
long @pattern_rain      +PATTERN_CW  + 0                &lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_bat       +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_ladder    +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_321       +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT 
long 0

hyper_hexagoner_patterns   
long @pattern_solo1     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  +10&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_triplec   +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 6&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo2     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 5&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo2_opp +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo3     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT 
long @pattern_solo3_dbl +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 6&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo3_thk +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT 
long @pattern_solo4     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 8&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo4_dbl +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo4_thk +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT     

long @pattern_whirlpool2+PATTERN_CW  + OFFSET_RANDOMIZE2&lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_3spin     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT 
long @pattern_rain      +PATTERN_CW  + 0                &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_bat       +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_ladder    +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_321       +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_multic    +PATTERN_CW  + OFFSET_RANDOMIZE2&lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT 
long @pattern_rain      +PATTERN_CW  + 0                &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
long 0

hexagonest_patterns
long @pattern_solo1     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 8&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_triplec   +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 6&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo2     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo2_opp +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo3     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT 
long @pattern_solo3_dbl +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo3_thk +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo4     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo4_dbl +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo4_thk +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT

long @pattern_whirlpool2+PATTERN_CW  + OFFSET_RANDOMIZE2&lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_4spin     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_321       +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT 
long @pattern_rain      +PATTERN_CW  + 0                &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT

long 0

hyper_hexagonest_patterns
long @pattern_solo1     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 8&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_triplec   +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 6&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo2     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 5&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo2_opp +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo3     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT 
long @pattern_solo3_dbl +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo3_thk +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo4     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo4_dbl +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo4_thk +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT

long @pattern_stair2    +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_whirlpool2+PATTERN_CW  + OFFSET_RANDOMIZE2&lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT 
long @pattern_rain      +PATTERN_CW  + 0                &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT 
long @pattern_4spin     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_321       +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT

long 0

blackwhite_patterns
long @pattern_solo1     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 7&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo1     +PATTERN_CW  + 0                &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo1     +PATTERN_CW  + 3                &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_triplec   +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_triplec   +PATTERN_CW  + 0                &lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_triplec   +PATTERN_CW  + 3                &lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo2     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 8&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo2_opp +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 8&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo3     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 7&lt;&lt;PATTERN_WEIGHT_SHIFT 
long @pattern_solo3_dbl +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 6&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo4     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 6&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo4_dbl +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_solo4_thk +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 4&lt;&lt;PATTERN_WEIGHT_SHIFT

long @pattern_stair1    +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_stair2    +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_whirlpool2+PATTERN_CW  + OFFSET_RANDOMIZE2&lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_321       +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_3spin     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_4spin     +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_multic    +PATTERN_CW  + OFFSET_RANDOMIZE2&lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT
long @pattern_ladder    +PATTERN_CW  + OFFSET_RANDOMIZE &lt;&lt;PATTERN_OFFSET_SHIFT  + 2&lt;&lt;PATTERN_WEIGHT_SHIFT 
long @pattern_rain      +PATTERN_CW  + 0                &lt;&lt;PATTERN_OFFSET_SHIFT  + 3&lt;&lt;PATTERN_WEIGHT_SHIFT

long 0

{
pattern_test
byte 2
byte W__X__X 
byte W__X___
byte 6 &apos; spacing
}
pattern_solo1
byte 1
byte WXXXXX_
byte 6 &apos; spacing

pattern_solo2
byte 1
byte W_XXX_X
byte 6 &apos; spacing


pattern_solo2_opp&apos;osing
byte 7
byte W_XXX_X 
byte W______[5]
byte WX_X_XX
byte 12 &apos; spacing

pattern_solo3
byte 1
byte WX_X_X_
byte 6 &apos; spacing

pattern_solo3_dbl
byte 3
byte WX_X_X_
byte W______
byte WX_X_X_
byte 6 &apos; spacing

pattern_solo3_thk
byte 2
byte WX_X_X_[2]
byte 6 &apos; spacing

pattern_triplec
byte 13
byte WXXXXX_
byte W______[5]
byte WXX_XXX
byte W______[5]
byte WXXXXX_
byte 18 &apos; spacing


pattern_solo4
byte 1
byte W__X__X
byte 5 &apos; spacing

pattern_solo4_dbl
byte 3
byte W__X__X
byte W______
byte W__X__X
byte 6 &apos; spacing

pattern_solo4_thk
byte 2
byte W__X__X 
byte W__X__X
byte 6 &apos; spacing

pattern_stair1
byte 16
byte WXX_XX_
byte W______[2]
byte WX_XX_X   
byte W______[2]
byte W_XX_XX 
byte W______[2]
byte WXX_XX_ 
byte W______[2]
byte WX_XX_X 
byte W______[2]
byte W_XX_XX    
byte 20 &apos; spacing

pattern_stair2
byte 16
byte WXX_XX_
byte W______[2]
byte WX_XX_X   
byte W______[2]
byte W_XX_XX 
byte W______[2]
byte WX_XX_X 
byte W______[2]
byte WXX_XX_  
byte W______[2]
byte W_XX_XX      
byte 20 &apos; spacing

pattern_multic
byte 16
byte WXXXXX_ 
byte W______[2]
byte WXXXX_X 
byte W______[2]
byte WXXX_XX 
byte W______[2]
byte WXX_XXX 
byte W______[2]
byte WX_XXXX
byte W______[2]
byte W_XXXXX                    
byte 20 &apos; spacing

pattern_rain
byte 13
byte WX_X_X_
byte W______[2] 
byte W_X_X_X
byte W______[2]
byte WX_X_X_
byte W______[2]
byte W_X_X_X  
byte W______[2]
byte WX_X_X_
byte 17 &apos; spacing (increased from 16?)


pattern_2spin
byte 16
byte WXXX__X
byte W_____X[2]
byte W__XXXX
byte W_____X[2]
byte WXXX__X
byte W_____X[2]
byte W__XXXX
byte W_____X[2]
byte WXXX__X
byte W_____X[2]
byte W__XXXX
byte 20 &apos; spacing

pattern_3spin
&apos;&apos; I slightly altered this pattern to make it shorter and more challenging
byte 23
byte WXXXX_X
byte WX____X[4]
byte WX_XXXX
byte WX__XXX
byte WX___XX
byte WX____X
byte WX____X
byte WXXXX_X
byte WXXX__X
byte WXX___X
byte WX____X
byte WX____X
byte WX_XXXX
byte WX__XXX
byte WX___XX
byte WX____X
byte WX____X
byte WXXXX_X
byte WXXX__X
byte WXX___X
byte 30 &apos; spacing

pattern_4spin
byte 13
byte W_XXXXX
byte W_____X[5]
byte WXXXX_X
byte W_____X[5]
byte W_XXXXX
byte 20 &apos; spacing

pattern_whirlpool
byte 16
byte WXXXXX_
byte WXXXX__
byte WXXX___
byte WXX____
byte WX____X
byte W____XX
byte W___XX_
byte W__XX__
byte W_XX___
byte WXX____ 
byte WX____X
byte W____XX
byte W___XX_
byte W__XXX_
byte W_XXXX_
byte WXXXXX_
byte 20 &apos; spacing TODO:remeasure

pattern_whirlpool2
&apos;&apos; This pattern seems to use weird 1.5 unit walls.
&apos;&apos; Have made them 1 unit and given it a kinda entry tunnel such that it is easier to not get snagged
byte 10
byte WXX_XX_
byte WXX_XX_
byte WX__X__
byte W__X__X
byte W_X__X_
byte WX__X__
byte W__X__X
byte W_X__X_
byte WX__X__
byte WX_XX_X 
byte 14 &apos; spacing

pattern_321
byte 16
byte WXXXXX_
byte W______[3]
byte WX___XX
byte WXX_XXX
byte WXX_XXX
byte W_____X
byte W_____X
byte W__X__X
byte W_XXX_X
byte W_XXX_X
byte W__X__X
byte W__X__X
byte WX___XX
byte WX___XX
byte 20 &apos; spacing

pattern_bat
byte 15
byte WXXXXX_
byte W_XXX__
byte W_XXX__
byte W_XXX__
byte W__X___
byte W__X__X
byte W__X__X
byte WX___XX
byte WX___XX
byte WX___XX
byte WXX_XXX[4]
byte WX___X_
byte 20 &apos; spacing

pattern_ladder
byte 13
byte WXX_XX_
byte WX__X__[2]
byte WX_XX_X
byte WX__X__[2]
byte WXX_XX_
byte WX__X__[2]
byte WX_XX_X
byte WX__X__[2]
byte WXX_XX_
byte 18 &apos; spacing


CON
  SNES_R      = %0000100000000000
  SNES_L      = %0000010000000000
  SNES_X      = %0000001000000000
  SNES_A      = %0000000100000000
  SNES_RIGHT  = %0000000010000000
  SNES_LEFT   = %0000000001000000
  SNES_DOWN   = %0000000000100000
  SNES_UP     = %0000000000010000
  SNES_START  = %0000000000001000
  SNES_SELECT = %0000000000000100
  SNES_Y      = %0000000000000010
  SNES_B      = %0000000000000001
PUB SNES_Read_Gamepad : nes_bits   |   i

DIRA [plat#SNES_LATCH] := 1 &apos; output
DIRA [plat#SNES_CLK] := 1 &apos; output
DIRA [plat#SNES_PLAYER1] := 0 &apos; input   

OUTA [plat#SNES_CLK] := 0
OUTA [plat#SNES_LATCH] := 0
waitcnt(381+cnt)
OUTA [plat#SNES_LATCH] := 1
waitcnt(381+cnt)  
OUTA [plat#SNES_LATCH] := 0
waitcnt(381+cnt)
nes_bits := 0
nes_bits := INA[plat#SNES_PLAYER1]&lt;&lt;16

repeat i from 0 to 14
  OUTA [plat#SNES_CLK] := 1 &apos; JOY_CLK = 1
  waitcnt(381+cnt) 
  OUTA [plat#SNES_CLK] := 0 &apos; JOY_CLK = 0
  waitcnt(381+cnt) 
  nes_bits := (nes_bits &lt;&lt; 1)
  nes_bits := nes_bits | INA[plat#SNES_PLAYER1]&lt;&lt;16

nes_bits := (!nes_bits)&gt;&lt;0

CON

W______ = %000000
W_____X = %000001
W____X_ = %000010
W____XX = %000011
W___X__ = %000100
W___X_X = %000101
W___XX_ = %000110
W___XXX = %000111
W__X___ = %001000
W__X__X = %001001
W__X_X_ = %001010
W__X_XX = %001011
W__XX__ = %001100
W__XX_X = %001101
W__XXX_ = %001110
W__XXXX = %001111
W_X____ = %010000
W_X___X = %010001
W_X__X_ = %010010
W_X__XX = %010011
W_X_X__ = %010100
W_X_X_X = %010101
W_X_XX_ = %010110
W_X_XXX = %010111
W_XX___ = %011000
W_XX__X = %011001
W_XX_X_ = %011010
W_XX_XX = %011011
W_XXX__ = %011100
W_XXX_X = %011101
W_XXXX_ = %011110
W_XXXXX = %011111
WX_____ = %100000
WX____X = %100001
WX___X_ = %100010
WX___XX = %100011
WX__X__ = %100100
WX__X_X = %100101
WX__XX_ = %100110
WX__XXX = %100111
WX_X___ = %101000
WX_X__X = %101001
WX_X_X_ = %101010
WX_X_XX = %101011
WX_XX__ = %101100
WX_XX_X = %101101
WX_XXX_ = %101110
WX_XXXX = %101111
WXX____ = %110000
WXX___X = %110001
WXX__X_ = %110010
WXX__XX = %110011
WXX_X__ = %110100
WXX_X_X = %110101
WXX_XX_ = %110110
WXX_XXX = %110111
WXXX___ = %111000
WXXX__X = %111001
WXXX_X_ = %111010
WXXX_XX = %111011
WXXXX__ = %111100
WXXXX_X = %111101
WXXXXX_ = %111110
WXXXXXX = %111111

{{
&boxdr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdl;
&boxv;                                    TERMS OF USE: Parallax Object Exchange License                                            &boxv;                                                            
&boxvr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxvl;
&boxv;Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation    &boxv; 
&boxv;files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy,    &boxv;
&boxv;modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software&boxv;
&boxv;is furnished to do so, subject to the following conditions:                                                                   &boxv;
&boxv;                                                                                                                              &boxv;
&boxv;The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.&boxv;
&boxv;                                                                                                                              &boxv;
&boxv;THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE          &boxv;
&boxv;WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR         &boxv;
&boxv;COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,   &boxv;
&boxv;ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                         &boxv;
&boxur;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxul;
}}
    </code></pre>
    <pre><code>
PUB sin(angle) : s | c,z
              &apos;angle: 0..8192 = 360&deg;
  s := angle
  if angle &amp; $800
    s := -s
  s |= $E000&gt;&gt;1
  s &lt;&lt;= 1
  s := word[s]
  if angle &amp; $1000
    s := -s                    &apos; return sin = -$FFFF..+$FFFF 
  frqa += 1

    </code></pre>
    <pre><code>
PUB multireturn(angle) : s,c,z
              &apos;angle: 0..8192 = 360&deg;
  s := angle
  if angle &amp; $800
    s := -s
  s |= $E000&gt;&gt;1
  s &lt;&lt;= 1
  s := word[s]
  if angle &amp; $1000
    s := -s                    &apos; return sin = -$FFFF..+$FFFF 

    </code></pre>
    <pre><code>
&apos;&apos; Voice architecture:                                        Parameters: (10 bytes)
&apos;&apos;                           &boxdr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdl;                          - volume              0..255
&apos;&apos; &boxdr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdl;  &boxdr;&boxh;&boxh;&boxh;&boxdl;           &boxv; Env &boxv;                          - panorama            0..127
&apos;&apos; &boxv; Osc2 &boxvr;&boxh;&boxh;&boxvl;&#xF082;&#xF085;&#xF082;&boxvr;&boxh;&boxhd;&boxh;&boxh;&boxh;&boxh;&boxdl;    &boxur;&boxh;&boxh;&boxhd;&boxh;&boxh;&boxul;      pl                  - semitone osc1       0..255
&apos;&apos; &boxur;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxul;  &boxur;&boxh;&boxh;&boxh;&boxul; &boxv;    &#xF0A2;    &boxdr;&boxh;&boxh;&boxhu;&boxh;&boxh;&boxdl;    &boxdr;&boxh;&#xF0A6;&#xF0A9;&boxh;&#xF0BB; L DAC          - semitone osc2       0..255
&apos;&apos;         pm&boxdr;&boxh;&boxh;&#xF08F;&boxvr;&boxh;&boxul;   (+)&boxh;&#xF0BB;&boxh;&boxvl; DCA &boxvr;&boxh;&boxhd;&boxh;&boxh;&boxvl;                     - detune osc2         0..255
&apos;&apos; &boxdr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdl;  &#xF0A2;  &boxdr;&boxh;&boxh;&boxh;&boxdl;   &#xF0A0;    &boxur;&boxh;&boxh;&boxh;&boxh;&boxh;&boxul; &boxv;  &boxur;&boxh;&#xF0A6;&#xF0A9;&boxh;&#xF0BB; R DAC          - PhaseMod intensity  7..0
&apos;&apos; &boxv; Osc1 &boxvr;&#xF0BB;(+)&boxh;&boxvl;&#xF082;&#xF085;&#xF082;&boxvr;&boxh;&boxh;&boxh;&boxhu;&boxh;&#xF0A6;&#xF0A9;&boxdl;pm      &boxv;    pr                  - Feedback intensity  7..0
&apos;&apos; &boxur;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxul;  &#xF0A0;  &boxur;&boxh;&boxh;&boxh;&boxul;       &#xF0A2;        &boxv;                        - Envelope Attack     0..255
&apos;&apos;           &boxur;&boxh;&boxh;&boxh;&boxh;&boxh;&#xF08F;&boxvr;&boxh;&boxh;&boxh;&boxh;&boxh;&#xF0BA;(+)&#xF0BA;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxul;                        - Envelope Decay&amp;Release  0..255
&apos;&apos;                 fb                                         - Envelope Sustain    0..255
&apos;&apos;
&apos;&apos;Legend: &#xF082;&#xF085;&#xF082; = Sawtooth&#xF0BB;Triangle Shaper, (+) = Mixer, &#xF0A6;&#xF0A9; &#xF08F;&boxvr; = 2^n Attenuator (shifts)
&apos;&apos; Osc = Sawtooth Oscillator  (DDS)
&apos;&apos; Env = Envelope Generator (A D/R S)
&apos;&apos; DCA = Digital Attenuator (mult 8*32)
    </code></pre>
    <pre><code>
CON
  APINS = 5 addpins 3
PUB main() | n
  pinstart(APINS,P_DAC_DITHER_RND,50_80,$8000)
  
  repeat
&#x9;do_stuff(n++)
&#x9;
PRI do_stuff(n)
  wypin(APINS,n.word[0] SCA $FF00)
    </code></pre>
    <pre><code>
{
################################################################################################################################
#         reSound - A sound driver and mixer for the Parallax Propeller 2 (Beta 2)   (C) 2020 Johannes Ahlebrand               #                                                            
################################################################################################################################
#                                    TERMS OF USE: Parallax Object Exchange License                                            #                                                            
################################################################################################################################
#Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation    # 
#files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy,    #
#modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software#
#is furnished to do so, subject to the following conditions:                                                                   #
#                                                                                                                              #
#The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.#
#                                                                                                                              #
#THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE          #
#WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR         #
#COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,   #
#ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                         #
################################################################################################################################
}

CON
  &apos; Setup configurations
  DAC_8BIT_NOISE         = %00_00_01  &apos; DAC 8-bit noise
  DAC_16BIT_PWM_DITHER   = %00_00_10  &apos; DAC 16-bit dither, noise
  DAC_16BIT_NOISE_DITHER = %00_00_11  &apos; DAC 16-bit dither, PWM
  ANALOG_990_OHM_3_3_V   = %00_00_00  &apos; 990 ohm, 3.3V
  ANALOG_600_OHM_2_0_V   = %01_00_00  &apos; 600 ohm, 2.0V
  ANALOG_123_OHM_3_3_V   = %10_00_00  &apos; 123 ohm, 3.3V
  ANALOG_75_OHM_2_0_V    = %11_00_00  &apos;  75 ohm, 2.0V
  DIR_ENABLE_OUTPUT      = %00_01_00
  DAC_MODE_PWM           = DIR_ENABLE_OUTPUT | ANALOG_75_OHM_2_0_V | DAC_16BIT_PWM_DITHER
  DAC_MODE_DEFAULT       = DIR_ENABLE_OUTPUT | ANALOG_75_OHM_2_0_V | DAC_16BIT_NOISE_DITHER
  DAC_MODE_NOISE         = DIR_ENABLE_OUTPUT | ANALOG_75_OHM_2_0_V | DAC_8BIT_NOISE

  &apos; Input to output mix options
  MIX_QUADRO             = %11111111_111_111_111_111_000_000_000_000
  MIX_STEREO             = %11111111_111_111_111_111_111_111_000_000
  MIX_MONO               = %11111111_111_111_111_111_111_111_111_000

  &apos; Input channel options
  SIGNED16            = %11111111_11111111111_11111_1111000_1
  SIGNED8             = %11111111_11111111111_11111_1001101_1
  UNSIGNED16          = %11111111_11111111111_11111_0111000_1
  UNSIGNED8           = %11111111_11111111111_11111_0001101_1
  ATTENTION           = %11111111_11111111111_00000_1111111_1
  HILO                = %11111111_11111111111_01000_1111111_1
  I_FX1               = %11111110_11111111111_11111_1111111_1
  I_FX2               = %11111101_11111111111_11111_1111111_1
  I_FX3               = %11111011_11111111111_11111_1111111_1
  I_FX4               = %11110111_11111111111_11111_1111111_1
  I_FX5               = %11101111_11111111111_11111_1111111_1
  I_FX6               = %11011111_11111111111_11111_1111111_1
  I_FX7               = %10111111_11111111111_11111_1111111_1
  I_FX8               = %01111111_11111111111_11111_1111111_1

  &apos; Common output options
  C_ATTENTION         = %00001111
  C_FX1               = %11111110
  C_FX2               = %11111101
  C_FX3               = %11111011
  C_FX4               = %11110111
  C_FX5               = %11101111
  C_FX6               = %11011111
  C_FX7               = %10111111
  C_FX8               = %01111111

  HZ = $8000_0000


PUB start()
&apos;
  coginit(COGEXEC_NEW, @RESOUND, hubFootprintStart)

PUB init(sysClock_1, mixingFrequency_1, forceHq_1, nrInputs_1, leftPin_1, rightPin_1, commonEffectsMask_1, enableAttention_1, hubRegPtr_1) 

&apos; Initialize reSound according to the parameters given in stereo mode
&apos;
    &apos; @sysClock          - The Parallax P2 system clock in Hz
    &apos; @mixingFrequency   - The mixing frequency that reSound should run at
    &apos; @forceHq           - This forces the sample period to be a multiple of 256 to enable the HQ PWM smart pin output mode
    &apos; @nrInputs          - The number of inputs buffers to process by the reSound mixer 
    &apos; @leftPin           - The smart pin number that should output the left audio signal
    &apos; @rightPin          - The smart pin number that should output the right audio signal
    &apos; @commonEffectsMask - Sets wich common effects should be used, such as reverb, lowpass filter, etc
    &apos; @enableAttention   - Enable cog attention events 
    &apos; @hubRegPtr         - A pointer to hub RAM where reSound should store its data (this memory chunk needs to be &quot;big enough&quot;)
&apos;

  left := leftPin_1
  right := rightPin_1
  initExplicit(sysClock_1, mixingFrequency_1, forceHq_1, nrInputs_1, 2, @left, commonEffectsMask_1, enableAttention_1, hubRegPtr_1)


PUB initExplicit(sysClock_2, mixingFrequency_2, forceHq, nrInputs_2, nrOutputs_2, pinConfigs_2, commonEffectsMask_2, enableAttention_2, hubRegPtr_2)
&apos;
&apos; Initialize reSound according to the parameters given in explicit mode
&apos;
    &apos; @sysClock           - The Parallax P2 system clock in Hz
    &apos; @mixingFrequency    - The mixing frequency that reSound should run at
    &apos; @forceHq            - This forces the sample period to be a multiple of 256 to enable the HQ PWM smart pin output mode
    &apos; @nrInputs           - The number of inputs buffers to process by the reSound mixer 
    &apos; @nrOutputs          - The number of analog output pins to use
    &apos; @pinConfigs         - A list of P2 pin numbers to use as analog outputs
    &apos; @commonEffectsMask  - Sets wich common effects should be used, such as reverb, lowpass filter, etc
    &apos; @enableAttention    - Enable cog attention events (needed for buffer fill interrupt handling)
    &apos; @hubRegPtr          - A pointer to hub RAM where reSound should store its data (this memory chunk needs to be &quot;big enough&quot;)
&apos;

  &apos; Initialize all outputs amplitudes to zero
  repeat i from 0 to 7
    outputAmplitude[i] := 0

  &apos; Setup reSound API variables and pointers
  systemClock := sysClock_2
  hiloMapPtr := hubRegPtr_2
  hubFootprintStart := hubRegPtr_2 + 4
  configurationPointer := hubFootprintStart
  configuredInputsCounter := 0
  numberOfInputs := nrInputs_2
  mixFrequency := mixingFrequency_2

  &apos; Setup the reSound driver init data
  word[configurationPointer][0] := systemClock / mixingFrequency_2 
  byte[configurationPointer][3] := nrInputs_2
  byte[configurationPointer][4] := nrOutputs_2
  byte[configurationPointer][5] := commonEffectsMask_2 

  if forceHq
    word[configurationPointer][0] := word[configurationPointer][0] &amp; $FF00

  &apos; Use the better quality option, PWM dither, if sysClock is a 256x multiple of the mixing frequency
  if (word[configurationPointer][0] &amp; $FF) == 0
    byte[configurationPointer][2] := DAC_MODE_PWM 
  else
    byte[configurationPointer][2] := DAC_MODE_DEFAULT 

  &apos; Set the right skip pattern for attention on/off
  if enableAttention_2
    byte[configurationPointer][6] := C_ATTENTION
  else
    byte[configurationPointer][6] := %11101111

  &apos; Increment the configuration pointer to point beyond the 7 static parameters
  configurationPointer += 7

  &apos; Register all smartpins that should be outputs
  repeat i from 0 to nrOutputs_2-1
    byte[configurationPointer][i] := byte[pinConfigs_2][i]

  &apos; Increment the configuration pointer to point beyond all the init data
  configurationPointer += nrOutputs_2

PUB configureInput(bufferPtr_3, bufferSize_3, maxBufferSize_3, frequency_3, optionsMask_3, attentionCogNr_3) : r
&apos;
&apos; Configure an input channel in stereo mode
&apos;
    &apos; @bufferPtr      - A pointer to the sound buffer in hub memory
    &apos; @bufferSize     - The size of the sound buffer in hub memory
    &apos; @maxBufferSize  - Sets the maximum allowed buffer size for this sound buffer (the smaller the better frequency resolution)
    &apos; @frequency      - The frequency to use when processing the sound buffer
    &apos; @optionsMask    - A skip pattern to enable/disable different sample processing options
    &apos; @attentionCogNr - If attention is enabled this sets the cog to get the attention of
&apos;

  r := configureInputExplicit(bufferPtr_3, bufferSize_3, maxBufferSize_3, frequency_3, optionsMask_3, MIX_STEREO, attentionCogNr_3) 
  &apos;return 


PUB configureInputExplicit(bufferPtr_4, bufferSize_4, maxBufferSize_4, frequency_4, optionsMask_4, outputMixMask_4, attentionCogNr_4) : r | nrOfMixes, inputHandle_1, bufferSizeShl, ptrAdjustment, phaseAccuShift
&apos;
&apos; Configure an input channel in explicit mode
&apos;
    &apos; @bufferPtr      - A pointer to the sound buffer in hub memory
    &apos; @bufferSize     - The size of the sound buffer in hub memory
    &apos; @maxBufferSize  - Sets the maximum allowed buffer size for this sound buffer (the smaller the better frequency resolution)
    &apos; @frequency      - The frequency to use when processing the sound buffer
    &apos; @optionsMask    - A skip pattern to enable/disable different sample processing options
    &apos; @outputMixMask  - A skip pattern do enable/disable mxing to different outputs
    &apos; @attentionCogNr - If attention is enabled this sets the cog to get the attention of
&apos;

  inputHandle_1 := configurationPointer &apos; Input handle is the start address of the current inputs parameters array in hub memory

  &apos; Get the accumulator shift amount based on the wanted buffer size
  maxBufferSize_4 := 33 - (encod maxBufferSize_4)

  &apos; Setup the first common options
  long[configurationPointer][0] := frequency_4      &apos; Frequency
  long[configurationPointer][4] := maxBufferSize_4  &apos; Shift amount, how many bits of the phase accumulator is used for the sample pointer?
  long[configurationPointer][5] := optionsMask_4    &apos; Common sample options, 8bit, 16bit, signed, unsigned, little/big endianess
  long[configurationPointer][6] := outputMixMask_4  &apos; Which output channels should output this input?

  phaseAccuShift := long[configurationPointer][4] &apos; Get the accumulator shift amount for this input
  bufferSizeShl  := bufferSize_4 &lt;&lt; phaseAccuShift
  ptrAdjustment  := -bufferSizeShl

  &apos; Handle 8 or 16 bit samples differently
  if(long[inputHandle_1][5] &amp; 32)
    ptrAdjustment &gt;&gt;= phaseAccuShift - 1 
  else
    ptrAdjustment &gt;&gt;= phaseAccuShift

  &apos; Fill in the rest of the common options
  long[configurationPointer][1] :=  bufferPtr_4 - ptrAdjustment &apos; Buffer pointer, where in hub memory is the starting point of the sample/buffer?
  long[configurationPointer][2] := -bufferSizeShl               &apos; Trigger point, from where in the buffer should we start playing?
  long[configurationPointer][3] :=  bufferSizeShl               &apos; Loop size, how big is the sample/buffer loop?

  &apos; Increment the configuration pointer to point beyond the 7 common fixed parameters
  configurationPointer += 28

  &apos; Increment the configuration pointer the right amount if the &quot;read in attention mask option&quot; is active
  if (optionsMask_4 &amp; (1 &lt;&lt; 8)) == 0
    word[configurationPointer] := 1 &lt;&lt; attentionCogNr_4
    &apos;configurationPointer += 2

  &apos; Increment the configuration pointer the right amount according to the number of effect parameter of the current input
  repeat i from 0 to 7
    if (optionsMask_4 &amp; (1 &lt;&lt; (i + 24))) == 0
      configurationPointer += inputEffectParams[i]

  &apos; Calcualte the amount of output channels that should be used when mixing this input channel
  nrOfMixes := (ones ((!outputMixMask_4) &amp; $00_ffffff)) / 3

  &apos; Initialize the volume level for each output to zero
  repeat i from 0 to nrOfMixes - 1
    word[configurationPointer][i] := 0 

  &apos; Increment the hub register pointer the right amount according to the selected number of output mixes for the current input
  configurationPointer += nrOfMixes &lt;&lt; 1 &apos; Each mix value is 16 bits

  &apos; Count how many inputs that have been configured
  configuredInputsCounter++

  return inputHandle_1


PUB playSample(inputHandle_2, samplePtr_2, length_2, loopSize_5, frequency_5, volume_2, panning_2) | mix1_2, mix2_2
&apos;
&apos; Play a sample in a specific input channel using stereo mode 
&apos;
    &apos; @inputHandle - A pointer to the parameter data in hub memory for a specific input
    &apos; @samplePtr   - A pointer in hub memory where the sample is located
    &apos; @length      - The number of samples that the audio sample contain
    &apos; @loopSize    - The number of samples that should be looped when reaching the end of the audio sample (1 means no loop)
    &apos; @frequency   - The frequency to play back the sample at
    &apos; @volume      - The volume that should be for mixing the input. A value from -16384 to 16383 (- means inverted waveform)
    &apos; @panning     - Panning right/left. 0 = max left, 65535 = max right, 32768 = in the middle
&apos;

  mix1_2 := ((65535 - panning_2) * volume_2) &gt;&gt; 16
  mix2_2 := (panning_2 * volume_2) &gt;&gt; 16
  playSampleExplicit(inputHandle_2, samplePtr_2, length_2, loopSize_5, frequency_5, mix1_2, mix2_2, 0, 0, 0, 0, 0, 0)


PUB playSampleExplicit(inputHandle_3, samplePtr_3, length_3, loopSize_6, frequency_6, mix1_3, mix2_3, mix3_3, mix4_3, mix5_3, mix6_3, mix7_3, mix8_3) | bufferSizeShl_2, ptrAdjustment_2, phaseAccuShift_2
&apos;
&apos; Play a sample in a specific input channel using explicit mode 
&apos;
    &apos; @inputHandle - A pointer to the parameter data in hub memory for a specific input
    &apos; @samplePtr   - A pointer in hub memory where the sample is located
    &apos; @length      - The number of samples that the audio sample contain
    &apos; @loopSize    - The number of samples that should be looped when reaching the end of the audio sample (1 means no loop)
    &apos; @frequency   - The frequency to play back the sample at
    &apos; @mix1 - mix8 - The gain values for up to 8 outputs. Should be a value from -16384 to 16383 (- means inverted waveform)
&apos;

  if samplePtr_3 == 0 or inputHandle_3 == 0
    return

  phaseAccuShift_2 := long[inputHandle_3][4] 
  bufferSizeShl_2  := length_3 &lt;&lt; phaseAccuShift_2
  ptrAdjustment_2  := -bufferSizeShl_2

  if(long[inputHandle_3][5] &amp; 32)
    ptrAdjustment_2 &gt;&gt;= phaseAccuShift_2 - 1  
  else
    ptrAdjustment_2 &gt;&gt;= phaseAccuShift_2

  ifnot inputHandle_3 == 0
    mixExplicit(inputHandle_3, frequency_6, 0, mix1_3, mix2_3, mix3_3, mix4_3, mix5_3, mix6_3, mix7_3, mix8_3)

  long[inputHandle_3][1] :=  samplePtr_3 - ptrAdjustment_2
  long[inputHandle_3][2] := -bufferSizeShl_2
  long[inputHandle_3][3] :=  loopSize_6 &lt;&lt; phaseAccuShift_2


PUB mix(inputHandle_4, freq_3, vol_3, pan_3) | mix1_4, mix2_4
&apos;
&apos; Mix a specific input channel in stereo mode using frequency, volume and panning parameters 
&apos;
    &apos; @inputHandle  - A pointer to the parameter data in hub memory for a specific input
    &apos; @freq         - The frequency that reSound mix the input at
    &apos; @vol          - The volume that should be for mixing the input. A value from -16384 to 16383 (- means inverted waveform)
    &apos; @pan          - Panning right/left. 0 = max left, 65535 = max right, 32768 = in the middle
&apos;

  mix1_4 := ((65535 - pan_3) * vol_3) &gt;&gt; 16
  mix2_4 := (pan_3 * vol_3) &gt;&gt; 16
  mixExplicit(inputHandle_4, freq_3, 0, mix1_4, mix2_4, 0, 0, 0, 0, 0, 0)


PUB mixExplicit(inputHandle_5, frequency_7, effects, mix1_5, mix2_5, mix3_5, mix4_5, mix5_5, mix6_5, mix7_5, mix8_5) | optionsMask_7, lastParam, j, headroom
&apos;
&apos; Mix a specific input channel in explicit mode using frequency, effect parameters and mix amounts for all outputs
&apos;
    &apos; @inputHandle  - A pointer to the parameter data in hub memory for a specific input
    &apos; @freq         - The frequency that reSound mix the input at
    &apos; @effects      - The effects parameters as a pointer to an array of 16 bits values
    &apos; @mix1 - mix8  - The gain values for up to 8 outputs. A value from -16384 to 16383 (- means inverted waveform)
&apos;

  if inputHandle_5 == 0 or frequency_7 == 0
    return    

  &apos; If the HZ bit is set (MSB), calculate the frequency in Hz instead of the raw phase frequency
  if frequency_7 &amp; HZ
    frequency_7 := frequency_7 &amp; $7FFF_FFFF
    frequency_7 := calculateFrequencyHz(mixFrequency, frequency_7, 1 &lt;&lt; (long[inputHandle_5][4]))

  &apos; Set the frequency
  long[inputHandle_5] := frequency_7
  optionsMask_7 := (long[inputHandle_5][5]) &apos; Get a copy of the options mask

  &apos; Point beyond the 7 longs fixed input parameters
  inputHandle_5 += 28

  &apos; Increment the inputHandle pointer the right amount if the attention option is active
  if (optionsMask_7 &amp; (1 &lt;&lt; 8)) == 0
    inputHandle_5 += 2

  &apos; Iterate over all enabled effect processors of the selected input and set each parameter
  repeat i from 0 to 7
    if (optionsMask_7 &amp; (1&lt;&lt;(24+i))) == 0

      lastParam := inputEffectParams[i] &gt;&gt; 1
      ifnot lastParam == 0
        --lastParam

        repeat j from 0 to lastParam
          word[inputHandle_5][j] := word[effects][j]

      inputHandle_5 += inputEffectParams[i]

  &apos; Iterate over all available outputs and set mix amount for this input
  repeat i from 0 to (byte[hubFootprintStart][4] - 1)   &apos; Number of enabled output pins

    outputAmplitude[i] -= word[inputHandle_5][i]
    headroom := 16384 - outputAmplitude[i]

    &apos; This logic handles so that too much gain doesn&apos;t clip/distort the composite audio signal
    if long[@mix1_5][i] &lt;= headroom
      word[inputHandle_5][i] := long[@mix1_5][i]
      outputAmplitude[i]     += long[@mix1_5][i]
    else
      word[inputHandle_5][i] := headroom
      outputAmplitude[i]     += headroom


&apos; Returns a handle as a reference to &quot;the right bit&quot; in the 32 bit HiLo map for a specific input
&apos;
PUB getHiloHandle() : r
  return (1 &lt;&lt; ((numberOfInputs + 1) - configuredInputsCounter))


&apos; Returns true if an unhandled buffer swap has occurred for a specific input 
&apos;
    &apos; @hiloHandle - A 32 bit mask value to pinpoint the right HiLo bit for a specific input
&apos;
PUB bufferSwapped(hiloHandle) : r

  if ((long[hiloMapPtr] ^ hiloXorMap) &amp; hiloHandle) == 0
    return false
  else
    hiloXorMap ^= hiloHandle    &apos; Flip the right Hilo xor map bit to indicate that the new buffer is handled
    return true


PUB getWriteBuffer(hiloHandle, inputHandle) : r | halfBufferOffset
&apos;
&apos; Returns a pointer to the back buffer for a specific input
&apos;
    &apos; @hiloHandle  - A 32 bit mask value to pinpoint the right HiLo bit for a specific input
    &apos; @inputHandle - A pointer to the parameter data in hub memory for a specific input
&apos;

  &apos; Return one of the double buffers (HI or LO) to be handled
  if long[hiloMapPtr] &amp; hiloHandle
    r := ((long[inputHandle][1]))
    &apos;return ((long[inputHandle][1]))                     &apos; Return LO buffer
  else
    halfBufferOffset := (-1 &gt;&gt; long[inputHandle][4]) + 1
    ifnot(long[inputHandle][5] &amp; 32)
      halfBufferOffset &gt;&gt;= 1
    r := ((long[inputHandle][1]) + halfBufferOffset)
    &apos;return ((long[inputHandle][1]) + halfBufferOffset)  &apos; Return HI buffer


PUB fillStereo16(inBuffer, nrSamples, inputHandle1, inputHandle2, hiloHandle) | audioBuffer1, audioBuffer2 
&apos;
&apos; Takes an array of multiplexed 16 bit stereo samples and demuxes/fills up two 16 bit input buffers
&apos;
    &apos; @inBuffer     - A pointer to the multiplexed 16 bit stereo data to process
    &apos; @nrSamples    - The number of muxed stereo samples to be processed
    &apos; @inputHandle1 - A pointer to the parameter data in hub memory for the first input
    &apos; @inputHandle2 - A pointer to the parameter data in hub memory for the second input
    &apos; @hiloHandle   - A 32 bit mask value to pinpoint the right HiLo bit for a specific input
&apos;

  &apos; Get pointers to the two input back buffers to fill up
  audioBuffer1 := getWriteBuffer(hiloHandle, inputHandle1)
  audioBuffer2 := getWriteBuffer(hiloHandle, inputHandle2)

  &apos; Demux the two 16 bit stereo channels into the two back buffers
  repeat i from 0 to nrSamples - 1 
    word[audioBuffer1][i] := word[inBuffer][ i &lt;&lt; 1]
    word[audioBuffer2][i] := word[inBuffer][(i &lt;&lt; 1) + 1]


&apos; Private helper functions
&apos;
PRI calculateFrequencyHz(mixingFrequency, frequency_8, accuTopBits) : r | upper, lower

  org
    QMUL    accuTopBits, frequency_8
    GETQX   lower
    GETQY   upper
    SETQ    upper
    QDIV    lower, mixingFrequency
    GETQX   frequency_8
  end

  return frequency_8


VAR
  long hiloMapPtr
  long hiloXorMap
  long hubFootprintStart
  long configurationPointer
  long systemClock
  byte left
  byte right
  long configuredInputsCounter
  long numberOfInputs
  long mixFrequency
  word outputAmplitude[8]
  long i



DAT org
&apos;######################################################################################################################
&apos;                             reSound v0.5 - Parallax Propeller 2 assembly source
&apos;######################################################################################################################

&apos;----------------------------------------------------------
&apos;            Read in all configuration parameters
&apos;----------------------------------------------------------
RESOUND       mov       hiloChnMapPtr, PTRA
              sub       hiloChnMapPtr, #4
              rdfast    #0, PTRA                          &apos; Read in the static configuration parameter first
              rfword    samplePeriod
              rfbyte    dacMode
              rfbyte    nrInputs
              rfbyte    numberOfOutputs
              and       numberOfOutputs, #7               &apos; There can never be more than 8 output channels
              mov       outputSkipPattern, numberOfOutputs&apos; Calculate the skip pattern to enable/disable outputs
              shl       outputSkipPattern, #1             
              sub       outputSkipPattern, #1
              bmask     outputSkipPattern
              xor       outputSkipPattern, mask16
              shl       outputSkipPattern, #16

              rfword    temp                              &apos; This load and sets the effect configuration
              setword   outputSkipPattern, temp, #0

              mov       itt, #0                           &apos; Dynamically read in up to 8 pin number definitions
              rep       #4, numberOfOutputs
                rfbyte  hubValue
                altd    itt, #pinDefinitions 
                mov     0-0, hubValue 
                add     itt, #1

&apos;----------------------------------------------------------
&apos; Configure the smartpin DAC mode according to the params                  
&apos;----------------------------------------------------------
              mov       smartpinConfig, dacMode           &apos; Smartpin DAC mode
              and       smartpinConfig, #%11
              shl       smartpinConfig, #1
              andn      dacMode, #%11                     &apos; DIR/OUT control
              shl       dacMode, #4
              or        smartpinConfig, dacMode
              and       smartpinConfig, #%11000110
              andn      dacMode, #$ff                     &apos; Analog out mode
              shl       dacMode, #8
              or        smartpinConfig, dacMode
              or        smartpinConfig, fixedConfigBits

              mov       itt, #0                           &apos; Iterate over and configure each smartpin
              rep       #5, numberOfOutputs
                alts    itt, #pinDefinitions
                wrpin   smartpinConfig, 0-0
                alts    itt, #pinDefinitions
                wxpin   samplePeriod, 0-0
                add     itt, #1

              mov       itt, #0                           &apos; Iterate over and enable all smartpin DAC outputs
              rep       #3, numberOfOutputs
                altd    itt, #pinDefinitions
                dirh    0-0
                add     itt, #1

              mov       temp, pinDefinitions              &apos; Configure selectable event 1 to triggers at each new sample period
              or        temp, #%001_000000
              setse1    temp
              add       PTRA, numberOfOutputs             &apos; Set the hub register pointer to the
              add       PTRA, #7                          &apos; &quot;per sample refreshed&quot; registers in hub memory

              nop
              nop
              nop
              nop
              nop
              nop
              nop
              nop
              nop
              nop
              nop
              nop
              nop
              nop


&apos;----------------------------------------------------------
&apos;----------------------------------------------------------
&apos;                        Main loop 
&apos;----------------------------------------------------------

mainLoop      rdfast    #0, PTRA
              mov       itt, nrInputs                       &apos; itt = input buffer index

&apos;----------------------------------------------------------
&apos;      Iterate over and process all input buffers 
&apos;----------------------------------------------------------
inBufferLoop  rflong    frequency                      wz &apos; Read in the first 7 fixed input buffer registers
        if_nz mov       phaseAccuNr, itt
              rflong    bufferPointer
              getptr    triggerOffsetPtr
              rflong    triggerOffset                  wz
              rflong    loopSize
              rflong    phaseShiftAmount
              rflong    optionsMask
              rflong    outputMixMask

              alts      phaseAccuNr, #511                 &apos; Handle phase accumulation, looping and sample pointer calculation
              mov       phase, 0-0
              add       phase, frequency               wc &apos; Add the frequency value into the phase accumulator
        if_c  sub       phase, loopSize                   &apos; Handle buffer looping
        if_nz mov       phase, triggerOffset
        if_nz wrlong    #0, triggerOffsetPtr
              altd      phaseAccuNr, #511
              mov       0-0, phase
              mov       phaseCopy, phase

&apos;----------------------------------------------------------
&apos;             Read in sample and handle options                    
&apos;----------------------------------------------------------
              shr       phase, phaseShiftAmount           &apos; Get the X top most bits of the phase as a offset into the sample buffer 
              skipf     optionsMask

&apos;              Common sample options (8 slots)
&apos;---------------------------------------------------------- 
              nop
              shl       phase, #1                         &apos; Shift from 8 to 16 bit sample address
              add       bufferPointer, phase              &apos; Add the phase to the buffer pointer
              rdword    hubSample, bufferPointer          &apos; Read 16 bit sample
              movbyts   hubSample, #%%01                  &apos; Handle big endianess
              rdbyte    hubSample, bufferPointer          &apos; Read 8 bit sample
              shl       hubSample, #8                     &apos; Convert 8 bit sample to 16 bit
              bitnot    hubSample, #15                    &apos; Handle unsigned sample

&apos;            attentionMask event option (5 slots)
&apos;---------------------------------------------------------- 
              rfword    temp                              &apos; Generate an attentionMask event on half and full buffer wraps
              add       phaseCopy, V8000000
        if_nc cmp       phaseCopy, frequency             wc
        if_c  or        attentionMask, temp 
        if_c  bitnot    hiloChnMap, itt 

&apos;             Free for future use (11 slots)
&apos;---------------------------------------------------------- 
              nop
              nop
              nop
              nop
              nop
              nop
              nop
              nop
              nop
              nop
              nop

&apos;          Call up to 8 input effect processors
&apos;---------------------------------------------------------- 
              call      #\inputEffect0 
              call      #\inputEffect1 
              call      #\inputEffect2 
              call      #\inputEffect3 
              call      #\inputEffect4 
              call      #\inputEffect5 
              call      #\inputEffect6 
              call      #\inputEffect7 

&apos;----------------------------------------------------------
&apos;                      Handle mixing 
&apos;----------------------------------------------------------    
              skipf     outputMixMask                      &apos; Dynamically mix current dry sample into up to 8 output pins
              rfword    mixAmount
              scas      hubSample, mixAmount
              adds      outSample + 0, #0
              rfword    mixAmount
              scas      hubSample, mixAmount
              adds      outSample + 1, #0
              rfword    mixAmount
              scas      hubSample, mixAmount
              adds      outSample + 2, #0
              rfword    mixAmount
              scas      hubSample, mixAmount
              adds      outSample + 3, #0
              rfword    mixAmount
              scas      hubSample, mixAmount
              adds      outSample + 4, #0
              rfword    mixAmount
              scas      hubSample, mixAmount
              adds      outSample + 5, #0
              rfword    mixAmount
              scas      hubSample, mixAmount
              adds      outSample + 6, #0
              rfword    mixAmount
              scas      hubSample, mixAmount
              adds      outSample + 7, #0

              adds      commonEffectSample + 0, hubSample  &apos; Mix current sample into up to 8 effects
              adds      commonEffectSample + 1, hubSample
              adds      commonEffectSample + 2, hubSample
              adds      commonEffectSample + 3, hubSample
              adds      commonEffectSample + 4, hubSample
              adds      commonEffectSample + 5, hubSample
              adds      commonEffectSample + 6, hubSample
              adds      commonEffectSample + 7, hubSample

              djnz      itt, #inBufferLoop                 &apos; Iterate to the next input buffer 

&apos;----------------------------------------------------------
&apos;   Output samples to the different DAC pins and 
&apos;   wait the remaining CPU cycles of the current period        
&apos;----------------------------------------------------------
              skipf     outputSkipPattern                 &apos; Call up to 8 common effect processors
              call      #\commonEffect0 
              call      #\commonEffect1 
              call      #\commonEffect2 
              call      #\commonEffect3 
              call      #\commonEffect4 
              call      #\commonEffect5 
              call      #\commonEffect6 
              call      #\commonEffect7 

              nop 
              nop
              nop
              nop       &apos;setq      #0                                 
              wrlong    hiloChnMap, hiloChnMapPtr 
              cmp       attentionMask, #0                   wz
        if_nz cogatn    attentionMask
        if_nz mov       attentionMask, #0

              wypin     outSample + 0, pinDefinitions + 0 &apos; Output signal on up to 8 smart pins 
              mov       outSample + 0, initDcLevel  
              wypin     outSample + 1, pinDefinitions + 1                          
              mov       outSample + 1, initDcLevel
              wypin     outSample + 2, pinDefinitions + 2              
              mov       outSample + 2, initDcLevel
              wypin     outSample + 3, pinDefinitions + 3    
              mov       outSample + 3, initDcLevel
              wypin     outSample + 4, pinDefinitions + 4              
              mov       outSample + 4, initDcLevel
              wypin     outSample + 5, pinDefinitions + 5                           
              mov       outSample + 5, initDcLevel
              wypin     outSample + 6, pinDefinitions + 6              
              mov       outSample + 6, initDcLevel
              wypin     outSample + 7, pinDefinitions + 7              
              mov       outSample + 7, initDcLevel

              waitse1                                     &apos; Wait until the right time to start next period
              jmp      #mainLoop                          &apos; Begin the processing of the next sample period


&apos;----------------------------------------------------------
&apos; Below follows all the &quot;heavy&quot; signal proccessing effects       
&apos;----------------------------------------------------------
&apos;----------------------------------------------------------
commonEffect0

&apos;----------------------------------------------------------
&apos;  Inc accs and generate RW pointers with random offsets
&apos;----------------------------------------------------------
             add       reverbPhase, reverbFrequency      wc    
        if_c getrnd    reverbWriteOffset
        if_c getrnd    reverbReadOffset1

        if_c add       revUpdate, revUpdateFreq
             cmp       revUpdate, revUpdateFreq          wz

             mov       reverbPhase180, reverbPhase
             add       reverbPhase180, V8000000             
             cmp       reverbFrequency, reverbPhase180   wc
       if_nc getrnd    reverbReadOffset2
             mov       reverbWritePtr, reverbPhase
             add       reverbWritePtr, reverbWriteOffset
             mov       reverbReadPtr1, reverbPhase
             add       reverbReadPtr1, reverbReadOffset1
             mov       reverbReadPtr2, reverbPhase180
             add       reverbReadPtr2, reverbReadOffset2
             shr       reverbReadPtr1, #32 - 9
             shr       reverbReadPtr2, #32 - 9
             shr       reverbWritePtr, #32 - 9

&apos;----------------------------------------------------------
&apos;    Generate two triangle waveforms 180 degress apart  
&apos;----------------------------------------------------------
             abs       reverbTriangle1, reverbPhase            
             fle       reverbTriangle1, ##$7FFF_FFFF
                   not       reverbTriangle2, reverbTriangle1
             zerox     reverbTriangle2, #30
             shr       reverbTriangle1, #16
             shr       reverbTriangle2, #16


&apos;----------------------------------------------------------
&apos;               Reverb signal processing
&apos;----------------------------------------------------------
             rdlut     sample + 0, reverbReadPtr1
             muls      sample + 0, reverbTriangle1
             sar       sample + 0, #16
             rdlut     sample + 1, reverbReadPtr2
             muls      sample + 1, reverbTriangle2
             sar       sample + 1, #16
             adds      sample + 0, sample + 1

             rdlut     temp2, reverbWritePtr

             &apos; Extract dry signal into temp
             mov       temp, outSample + 0
             add       temp, outSample + 1
             sub       temp, ##65536
             sar       temp, #1

             &apos; Gain wet signal
             mul       reverbTriangle1, ##13710
             sar       reverbTriangle1, #15
             muls      temp, reverbTriangle1
             sar       temp, #16

             &apos; Wet decay speed
             adds      temp2, temp
             muls      temp2, ##31781
             sar       temp2, #15

             if_z wrlut     temp2, reverbWritePtr


             subs      outSample + 1, sample + 0
             adds      outSample + 0, sample + 0

             &apos;mov       outSample + 1, sample + 0
             &apos;mov       outSample + 0, sample + 0
             &apos;add       outSample + 0, ##32768
             &apos;add       outSample + 1, ##32768


commonEffect0_ret   ret

&apos;----------------------------------------------------------
commonEffect1
             mov      highPassFilter, outSample + 0
             add      highPassFilter, outSample + 1
             sub      highPassFilter, ##65536
             mov      filterResonance, #0
             mov      filterCutoff, ##12192

&apos;-----------------------------------------------------------
             mov      temp, bandPassFilter  
             muls     temp, filterResonance                &apos; Highpass filter
             sar      temp, #5
             subs     highPassFilter, bandPassFilter 
             adds     highPassFilter, temp 
             subs     highPassFilter, lowPassFilter 
&apos;----------------------------------------------------------- 
             mov      temp, highPassFilter 
             muls     temp, filterCutoff                   &apos; Bandpass filter
             sar      temp, #16
             adds     bandPassFilter, temp 
&apos;----------------------------------------------------------- 
             mov      temp, bandPassFilter 
             muls     temp, filterCutoff                   &apos; Lowpass filter 
             sar      temp, #16 
             adds     lowPassFilter, temp 
&apos;-----------------------------------------------------------  
             mov      temp, ##32768
             adds     temp, lowPassFilter
             adds     temp, bandPassFilter                 &apos; Enable filter types
             &apos;adds     temp, highPassFilter
             mov      outSample + 0, temp
             mov      outSample + 1, temp




commonEffect1_ret   ret
&apos;----------------------------------------------------------
commonEffect2
commonEffect2_ret   ret
&apos;----------------------------------------------------------
commonEffect3
commonEffect3_ret   ret
&apos;----------------------------------------------------------
commonEffect4
commonEffect4_ret   ret
commonEffect5
commonEffect5_ret   ret
commonEffect6
commonEffect6_ret   ret
commonEffect7
commonEffect7_ret   ret

&apos; Distortion effect
inputEffect0
              rfword    effectParameter+0            &apos; Read DC offset parameter
              rfword    effectParameter+1            &apos; Read gain level parameter
              rfword    effectParameter+2            &apos; Read wet/dry level parameter

              signx     hubSample, #15               &apos; Fix hubSample sign extension
              mov       signal, hubSample
              signx     effectParameter+0, #15       &apos; Fix DC offset parameter sign extionsion

              adds      signal, effectParameter+0

              muls      signal, effectParameter+1
              sar       signal, #8 

              fles      signal, clipHigh
              fges      signal, clipLow

              scas      hubSample, effectParameter+2
              mov       hubSample, #0

              neg       effectParameter+2
              add       effectParameter+2, ##8192

              scas      signal, effectParameter+2
              adds      hubSample, #0    


inputEffect0_ret   ret

inputEffect1
inputEffect1_ret   ret
inputEffect2
inputEffect2_ret   ret
inputEffect3
inputEffect3_ret   ret
inputEffect4
inputEffect4_ret   ret
inputEffect5
inputEffect5_ret   ret
inputEffect6
inputEffect6_ret   ret
inputEffect7
inputEffect7_ret   ret


&apos;----------------------------------------------------------
&apos;                Variables / Constants / Data
&apos;----------------------------------------------------------

reverbPhase            long  0
reverbPhase180         long  $8000_0000
reverbWriteOffset      long  0
reverbReadOffset1      long  0
reverbReadOffset2      long  0
reverbTriangle1        long  0
reverbTriangle2        long  0
V8000000               long  $8000_0000

fixedConfigBits        long  %10100_00000000_00_00000_0
initDcLevel            long  32768
mask16                 long  $0000_ffff
clipHigh               long  32767
clipLow                long  -32768
&apos;reverbFrequency        long  $0275319
reverbFrequency        long  $0400_000

revUpdate              long  0
revUpdateFreq          long  $2000_0000
attentionMask          long  0
hiloChnMap             long  0

phaseAccuNr            res   1
filterCutoff           res   1
filterResonance        res   1
highPassFilter         res   1
bandPassFilter         res   1
lowPassFilter          res   1
hiloChnMapPtr          res   1
sample                 res   2
reverbWritePtr         res   1
reverbReadPtr1         res   1
reverbReadPtr2         res   1
delayCounter           res   1
signal                 res   1
outputSkipPattern      res   1
samplePeriod           res   1
dacMode                res   1
nrInputs               res   1
numberOfOutputs        res   1
frequency              res   1
bufferPointer          res   1
triggerOffset          res   1
loopSize               res   1
optionsMask            res   1
temp                   res   1
temp2                  res   1
itt                    res   1
hubValue               res   1
smartpinConfig         res   1
hubSample              res   1
phase                  res   1
phaseCopy              res   1
cogMemSamplePtr        res   1
outputMixMask          res   1
mixAmount              res   1
phaseShiftAmount       res   1
triggerOffsetPtr       res   1
sendSignal             res   1
pinDefinitions         res   8
effectParameter        res   8
outSample              res   8
commonEffectSample     res   8

                       fit   496     


DAT
inputEffectParams byte 6, 0, 0, 0, 0, 0, 0, 0
    </code></pre>
</body>
